type array = Array<any>;

type DomElement = { [x: string]: any } & (Element | SVGElement);
type DomText = Text;

type DomAttribute = { nodeName: string; nodeValue: string };

type Props = { [propName in string | number]: unknown } & {
  key?: string | number;
  data?: string;
  oncreate?: { (vnode: Vnode): never };
  onupdate?: { (vnode: Vnode, oldVnode: Vnode | TextVnode): never };
  onremove?: { (oldVnode: Vnode): never };
  onbeforeupdate?: { (vnode: Vnode, oldVnode: Vnode | TextVnode): undefined | boolean };
};

interface IComponent {
  (props?: Props | null, children?: array): Array<any> | Vnode | TextVnode | any;
}

interface IValyrian {
  (tagOrComponent: string | IComponent, props?: Props | null, children?: array): Array<any> | Vnode | TextVnode | any;
}

interface Plugin {
  (v: IValyrian, options: object): unknown;
}

type Current = { parentVnode: Vnode | undefined; oldParentVnode: Vnode | undefined; component: Component | POJOComponent | undefined };

class Vnode {
  name: string;
  props: Props;
  children: array;
  dom?: DomElement;

  constructor(name: string, props: Props, children: array) {
    this.props = props;
    this.children = children;
    this.name = name;
  }
}

class TextVnode {
  dom?: DomElement;

  constructor(dom?: DomElement) {
    this.dom = dom;
  }
}

class Component {
  component: IComponent;
  props: Props | null;
  children: array;

  constructor(component: IComponent, props: Props | null, children: array) {
    this.props = props;
    this.children = children;
    this.component = component;
  }
}

const UND: undefined = undefined;
const isArray = Array.isArray;

const createElement = (tag: string, isSVG: boolean = false) => (isSVG ? document.createElementNS("http://www.w3.org/2000/svg", tag) : document.createElement(tag));

// Hydrates the current dom before mount
const domToVnode = (dom: DomElement) => {
  if (dom.nodeType === 1) {
    let props = {};
    [].forEach.call(dom.attributes, (prop) => ((props as Props)[(prop as DomAttribute).nodeName] = (prop as DomAttribute).nodeValue));

    let vnode = new Vnode(dom.nodeName, props, []);
    vnode.dom = dom;

    for (let i = 0, l = dom.childNodes.length; i < l; i++) {
      let childVnode = domToVnode(dom.childNodes[i] as DomElement);
      childVnode && vnode.children.push(childVnode);
    }
    return vnode;
  }
  if (dom.nodeType === 3) {
    return new TextVnode(dom);
  }
};

const emptyNode = new Vnode("empty", null, []);

const isNode = new Function("try {return this===global;}catch(e){return false;}")();

const trust = (htmlString: string) => {
  let div = createElement("div");
  div.innerHTML = htmlString.trim();

  return [].map.call(div.childNodes, (item) => domToVnode(item));
};

//eslint-disable-next-line max-lines-per-function
function valyrian() {
  function v(tagOrComponent: string | IComponent, props: Props | null = {}, ...children: array) {
    if (props === null) {
      props = {};
    }
    if (typeof tagOrComponent === "string") {
      return new Vnode(tagOrComponent, props, children);
    }

    return new Component(tagOrComponent as IComponent, props, children);
  }

  v.isMounted = false;

  v.isNode = isNode;

  let mainContainer: DomElement | null = null;
  let mainNode: Vnode;
  let oldMainNode: Vnode;
  let mountedComponent: IComponent;

  let attachedListeners: { [x: string]: boolean } = {};
  function eventListener(e: Event) {
    let dom = e.target as DomElement;
    let name = `__on${e.type}`;
    while (dom) {
      if (dom[name]) {
        dom[name](e, dom);
        if (!e.defaultPrevented) {
          v.update();
        }
        return;
      }
      dom = dom.parentNode as DomElement;
    }
  }

  v.trust = trust;

  v.updateProperty = (name: string, newNode: Vnode, { props }: Vnode = emptyNode) => {
    if (typeof newNode.props[name] === "function") {
      name = `__${name}`;
      if (!attachedListeners[name]) {
        (mainContainer as DomElement).addEventListener(name.slice(4), eventListener);
        attachedListeners[name] = true;
      }
      (newNode.dom as DomElement)[name] = newNode.props[name];
    } else if (name in (newNode.dom as DomElement)) {
      if ((newNode.dom as DomElement)[name] != newNode.props[name]) {
        (newNode.dom as DomElement)[name] = newNode.props[name];
      }
    } else if (newNode.props[name] !== props[name]) {
      (newNode.dom as DomElement).setAttribute(name, newNode.props[name] as string);
    }
  };

  let updateProps = (newNode: Vnode, oldNode: Vnode) => {
    for (let name in newNode.props) {
      v.updateProperty(name, newNode, oldNode);
    }
  };

  let removeProps = (newNode: Vnode, oldNode: Vnode) => {
    for (let name in oldNode.props) {
      if (name in newNode.props === false && typeof oldNode.props[name] !== "function") {
        if (name in (newNode.dom as DomElement)) {
          (newNode.dom as DomElement)[name] = null;
        } else {
          (newNode.dom as DomElement).removeAttribute(name);
        }
      }
    }
  };

  // eslint-disable-next-line complexity,sonarjs/cognitive-complexity
  let patch = (parentNode: Vnode, oldParentNode: Vnode = emptyNode) => {
    let newTree = [parentNode.children];
    let oldTree = oldParentNode.children;

    // Flatten children
    for (let i = 0; i < newTree.length; i++) {
      let childVnode: any = newTree[i];

      if (childVnode === null || childVnode === UND) {
        newTree.splice(i--, 1);
      } else if (childVnode instanceof Component) {
        newTree.splice(i--, 1, childVnode.component.call(childVnode.component, childVnode.props, ...childVnode.children));
      } else if (isArray(childVnode)) {
        newTree.splice(i--, 1, ...childVnode);
      }
    }

    // New Tree is empty
    if (newTree.length === 0) {
      if (oldTree.length > 0) {
        // Fast node remove by setting textContent
        (parentNode.dom as DomElement).textContent = "";
      }
    } else {
      let i = oldTree.length;
      let l = newTree.length;

      // Remove deleted nodes
      while (i-- > l) {
        let oldVnode = oldTree[i];
        oldVnode.dom && oldVnode.dom.parentNode && oldVnode.dom.parentNode.removeChild(oldVnode.dom);
      }

      for (i = 0; i < l; i++) {
        let newNode = newTree[i] as Vnode | TextVnode | any;
        let oldNode = (oldTree[i] as Vnode | TextVnode) || emptyNode;

        // Is vnode
        if (newNode instanceof Vnode) {
          // New node
          if (oldNode === emptyNode) {
            newNode.dom = createElement(newNode.name);
            updateProps(newNode, oldNode as Vnode);
            (parentNode.dom as DomElement).appendChild(newNode.dom);
            patch(newNode, oldNode as Vnode);
          } else {
            // Same node name
            if (newNode.name === (oldNode as Vnode).name) {
              newNode.dom = oldNode.dom;
              removeProps(newNode, oldNode as Vnode);
              updateProps(newNode, oldNode as Vnode);
              patch(newNode, oldNode as Vnode);

              // Different node name
            } else {
              newNode.dom = createElement(newNode.name);
              updateProps(newNode, emptyNode);
              (parentNode.dom as DomElement).replaceChild(newNode.dom, (parentNode.dom as DomElement).childNodes[i]);
              patch(newNode, emptyNode);
            }
          }

          // Is TextVnode or will be
        } else {
          let dom;

          // If we are getting a TextVnode could be from the domToVnode method
          let value = newNode instanceof TextVnode ? (newNode.dom as DomElement).nodeValue : typeof newNode === "string" ? newNode : String(newNode);

          if (oldNode instanceof TextVnode) {
            dom = oldNode.dom;
            if (value != (dom as DomElement).nodeValue) {
              (dom as DomElement).nodeValue = value;
            }
          } else {
            dom = document.createTextNode(value as string);
            if (oldNode === emptyNode) {
              (parentNode.dom as DomElement).appendChild(dom);
            } else {
              (parentNode.dom as DomElement).replaceChild(dom, oldNode.dom as DomElement);
            }
          }
          newTree[i] = new TextVnode(dom as DomElement);
        }
      }
    }

    parentNode.children = newTree;
  };

  v.update = (props?: Props, ...children: array) => {
    if (mainNode) {
      if (mountedComponent) {
        oldMainNode = mainNode;
        mainNode = new Vnode(mainNode.name, mainNode.props, [v(mountedComponent, props, ...children)]);
        mainNode.dom = oldMainNode.dom;
        mainNode.isSVG = mainNode.name === "svg";
        patch(mainNode, oldMainNode);
        v.isMounted = true;
      }

      return v.isNode && (mainNode.dom as DomElement).innerHTML;
    }
  };

  v.mount = (container: string, component: IComponent, props: Props, ...children: array) => {
    mainContainer = v.isNode ? createElement(container) : document.querySelectorAll(container)[0];
    mainNode = domToVnode(mainContainer) as Vnode;
    mountedComponent = component;

    return v.update(props, ...children);
  };

  v.unMount = () => {
    mainContainer = null;
    mountedComponent = () => "";
    let result = v.update();
    v.isMounted = false;
    return result;
  };

  v.newInstance = valyrian;

  return v;
}

module.exports = valyrian();
