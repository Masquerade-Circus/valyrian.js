{
  "version": 3,
  "sources": ["../../lib/forms/index.ts", "../../node_modules/schema-shield/dist/index.mjs"],
  "sourcesContent": ["import { directive, VnodeWithDom } from \"valyrian.js\";\nimport { createPulseStore } from \"valyrian.js/pulses\";\nimport { isFunction, isString } from \"valyrian.js/utils\";\nimport { SchemaShield, ValidationError, Validator } from \"schema-shield\";\n\ntype JsonSchema = Record<string, unknown>;\nexport type FormState = Record<string, unknown>;\n\ntype EventHandler = ((event: Event) => void) | null;\n\ntype FormControl = {\n  name?: string;\n  type?: string;\n  tagName?: string;\n  value?: unknown;\n  checked?: boolean;\n  disabled?: boolean;\n  oninput?: EventHandler;\n  onchange?: EventHandler;\n  getAttribute?: (name: string) => string | null;\n  vnode?: { props?: Record<string, unknown> };\n};\n\ntype FormNode = {\n  nodeType?: number;\n  childNodes?: FormNode[];\n  tagName?: string;\n  type?: string;\n  disabled?: boolean;\n  onsubmit?: ((event: Event) => Promise<void> | void) | null;\n  getAttribute?: (name: string) => string | null;\n  vnode?: { props?: Record<string, unknown> };\n};\n\nexport type FormTransformContext<TState extends FormState> = {\n  name: keyof TState | string;\n  state: TState;\n  control: FormControl | null;\n  event?: Event;\n};\n\nexport type FormTransform<TState extends FormState> = (\n  value: unknown,\n  context: FormTransformContext<TState>\n) => unknown;\n\nexport type FormTransformMap<TState extends FormState> = Partial<\n  Record<keyof TState | string, FormTransform<TState>>\n>;\n\nexport type FormOptions<TState extends FormState> = {\n  state: TState;\n  schema: JsonSchema;\n  clean?: FormTransformMap<TState>;\n  format?: FormTransformMap<TState>;\n  onSubmit?: (values: TState) => Promise<void> | void;\n};\n\ntype FormInternalState<TState extends FormState> = {\n  values: TState;\n  errors: Record<string, string>;\n  isInflight: boolean;\n  isDirty: boolean;\n};\n\ntype FormInternalPulses<TState extends FormState> = {\n  setValue: (state: FormInternalState<TState>, name: string, value: unknown) => void;\n  setErrors: (state: FormInternalState<TState>, errors: Record<string, string>) => void;\n  setInflight: (state: FormInternalState<TState>, inflight: boolean) => void;\n  reset: (state: FormInternalState<TState>) => void;\n};\n\ntype FormPulseStore<TState extends FormState> = {\n  state: FormInternalState<TState>;\n  setValue: (name: string, value: unknown) => void;\n  setErrors: (errors: Record<string, string>) => void;\n  setInflight: (inflight: boolean) => void;\n  reset: () => void;\n};\n\ntype ControlBinding = {\n  formStore: FormStore<FormState>;\n  name: string;\n  type: string;\n  onInput: EventHandler;\n  onChange: EventHandler;\n};\n\ntype FormBinding = {\n  formStore: FormStore<FormState>;\n  onSubmit: ((event: Event) => Promise<void> | void) | null;\n};\n\nconst controlBindingKey = Symbol(\"forms-control-binding\");\nconst formBindingKey = Symbol(\"forms-form-binding\");\n\nfunction getTagName(node: FormNode | FormControl) {\n  return String(node.tagName || \"\").toUpperCase();\n}\n\nfunction getNodeAttribute(node: FormNode | FormControl, attributeName: string) {\n  if (!isFunction(node.getAttribute)) {\n    return null;\n  }\n  return node.getAttribute(attributeName);\n}\n\nfunction getNodeName(node: FormControl) {\n  const vnodeName = node.vnode?.props?.name;\n  if (isString(vnodeName)) {\n    return vnodeName;\n  }\n\n  if (isString(node.name)) {\n    return node.name;\n  }\n\n  const attributeName = getNodeAttribute(node, \"name\");\n  return isString(attributeName) ? attributeName : \"\";\n}\n\nfunction getNodeType(node: FormControl) {\n  return String(node.type || getNodeAttribute(node, \"type\") || \"\").toLowerCase();\n}\n\nfunction decodeJsonPointerToken(token: string) {\n  return token.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nfunction getFieldNameFromError(error: ValidationError) {\n  const path = String(error.getPath().instancePath || \"\");\n  if (path.startsWith(\"#/\")) {\n    const token = path.slice(2).split(\"/\")[0];\n    if (token.length > 0) {\n      return decodeJsonPointerToken(token);\n    }\n  }\n\n  if (isString(error.item)) {\n    return error.item;\n  }\n\n  return null;\n}\n\nfunction getFieldNameFromChain(error: ValidationError) {\n  let current: ValidationError | undefined = error;\n  while (current) {\n    const fieldName = getFieldNameFromError(current);\n    if (fieldName) {\n      return fieldName;\n    }\n    current = current.cause;\n  }\n  return null;\n}\n\nfunction getRootError(error: ValidationError) {\n  let current: ValidationError = error;\n  while (current.cause) {\n    current = current.cause;\n  }\n  return current;\n}\n\nfunction cloneStateShallow<TState extends FormState>(state: TState): TState {\n  const clone = Object.create(Object.getPrototypeOf(state)) as TState;\n  return Object.assign(clone, state);\n}\n\nfunction walkElements(root: FormNode, visitor: (node: FormNode) => void) {\n  const children = root.childNodes || [];\n  for (const child of children) {\n    if (!child || child.nodeType !== 1) {\n      continue;\n    }\n    visitor(child);\n    walkElements(child, visitor);\n  }\n}\n\nfunction getControls(formDom: FormNode) {\n  const controls: FormControl[] = [];\n\n  walkElements(formDom, (node) => {\n    const tagName = getTagName(node);\n    if (tagName !== \"INPUT\" && tagName !== \"SELECT\" && tagName !== \"TEXTAREA\") {\n      return;\n    }\n\n    const control = node as unknown as FormControl;\n    const controlName = getNodeName(control);\n    if (controlName.length === 0) {\n      return;\n    }\n\n    control.name = controlName;\n    controls.push(control);\n  });\n\n  return controls;\n}\n\nfunction getSubmitters(formDom: FormNode) {\n  const submitters: FormNode[] = [];\n\n  walkElements(formDom, (node) => {\n    const tagName = getTagName(node);\n    const nodeType = String(node.type || getNodeAttribute(node, \"type\") || \"\").toLowerCase();\n    if ((tagName === \"BUTTON\" || tagName === \"INPUT\") && nodeType === \"submit\") {\n      submitters.push(node);\n    }\n  });\n\n  return submitters;\n}\n\nfunction setControlValue(control: FormControl, value: unknown) {\n  control.value = value == null ? \"\" : value;\n}\n\nexport class FormStore<TState extends FormState> {\n  static #schemaShield = FormStore.createSchemaShield();\n\n  #validator: Validator;\n  #onSubmit: ((values: TState) => Promise<void> | void) | null;\n  #clean: FormTransformMap<TState>;\n  #format: FormTransformMap<TState>;\n  #pulseStore: FormPulseStore<TState>;\n\n  static createSchemaShield() {\n    const schemaShield = new SchemaShield({\n      failFast: false,\n      immutable: true\n    });\n\n    schemaShield.addFormat(\n      \"url\",\n      (value: unknown) => {\n        if (!isString(value)) {\n          return false;\n        }\n\n        try {\n          const parsedUrl = new URL(value);\n          return parsedUrl.protocol.length > 0;\n        } catch {\n          return false;\n        }\n      },\n      true\n    );\n\n    return schemaShield;\n  }\n\n  constructor(options: FormOptions<TState>) {\n    this.#validator = FormStore.#schemaShield.compile(options.schema);\n    this.#onSubmit = options.onSubmit || null;\n    this.#clean = options.clean || {};\n    this.#format = options.format || {};\n\n    const initialValues = cloneStateShallow(options.state);\n\n    this.#pulseStore = createPulseStore<FormInternalState<TState>, FormInternalPulses<TState>>(\n      {\n        values: cloneStateShallow(initialValues),\n        errors: {},\n        isInflight: false,\n        isDirty: false\n      },\n      {\n        setValue(state, name, value) {\n          (state.values as FormState)[name] = value;\n          state.isDirty = true;\n        },\n        setErrors(state, errors) {\n          state.errors = errors;\n        },\n        setInflight(state, inflight) {\n          state.isInflight = inflight;\n        },\n        reset(state) {\n          state.values = cloneStateShallow(initialValues);\n          state.errors = {};\n          state.isInflight = false;\n          state.isDirty = false;\n        }\n      }\n    ) as unknown as FormPulseStore<TState>;\n  }\n\n  get state() {\n    return this.#pulseStore.state.values;\n  }\n\n  get errors() {\n    return this.#pulseStore.state.errors;\n  }\n\n  get isInflight() {\n    return this.#pulseStore.state.isInflight;\n  }\n\n  get isDirty() {\n    return this.#pulseStore.state.isDirty;\n  }\n\n  #runTransform(\n    map: FormTransformMap<TState>,\n    name: string,\n    value: unknown,\n    control: FormControl | null,\n    event?: Event\n  ) {\n    const transform = map[name];\n    if (!transform) {\n      return value;\n    }\n\n    return transform(value, {\n      name,\n      state: this.state,\n      control,\n      event\n    });\n  }\n\n  formatValue(name: string, value: unknown, control: FormControl | null = null) {\n    return this.#runTransform(this.#format, name, value, control);\n  }\n\n  setField(name: string, rawValue: unknown, control: FormControl | null = null, event?: Event) {\n    const cleanedValue = this.#runTransform(this.#clean, name, rawValue, control, event);\n    this.#pulseStore.setValue(name, cleanedValue);\n    this.validate();\n  }\n\n  #mapValidationError(error: ValidationError | true | null) {\n    if (!error) {\n      return {};\n    }\n\n    if (error === true) {\n      return { _form: \"Invalid form data\" };\n    }\n\n    const fieldName = getFieldNameFromChain(error);\n    const rootError = getRootError(error);\n    const message = rootError.message || \"Invalid form data\";\n\n    if (!fieldName) {\n      return { _form: message };\n    }\n\n    return { [fieldName]: message };\n  }\n\n  validate() {\n    const result = this.#validator(this.state);\n    const errors = result.valid ? {} : this.#mapValidationError(result.error);\n    this.#pulseStore.setErrors(errors);\n    return Object.keys(errors).length === 0;\n  }\n\n  async submit(event?: Event) {\n    event?.preventDefault();\n\n    if (!this.validate()) {\n      return false;\n    }\n\n    if (this.isInflight) {\n      return false;\n    }\n\n    this.#pulseStore.setInflight(true);\n\n    try {\n      if (this.#onSubmit) {\n        await this.#onSubmit(this.state);\n      }\n      return true;\n    } finally {\n      this.#pulseStore.setInflight(false);\n    }\n  }\n\n  reset() {\n    this.#pulseStore.reset();\n  }\n}\n\nfunction bindControl(formStore: FormStore<FormState>, control: FormControl) {\n  const name = getNodeName(control);\n  if (name.length === 0) {\n    return;\n  }\n\n  control.name = name;\n\n  const type = getNodeType(control);\n  const tagName = getTagName(control);\n  const stateValue = formStore.state[name];\n\n  if (type === \"checkbox\") {\n    control.checked = Boolean(stateValue);\n  } else if (type === \"radio\") {\n    control.checked = String(stateValue) === String(control.value || \"\");\n  } else if (tagName === \"SELECT\" || tagName === \"TEXTAREA\" || tagName === \"INPUT\") {\n    const formattedValue = formStore.formatValue(name, stateValue, control);\n    setControlValue(control, formattedValue);\n  }\n\n  const withBinding = control as FormControl & { [controlBindingKey]?: ControlBinding };\n  if (!withBinding[controlBindingKey]) {\n    const binding: ControlBinding = {\n      formStore,\n      name,\n      type,\n      onInput: control.oninput || null,\n      onChange: control.onchange || null\n    };\n\n    withBinding[controlBindingKey] = binding;\n\n    control.oninput = (event: Event) => {\n      const currentBinding = withBinding[controlBindingKey];\n      if (!currentBinding) {\n        return;\n      }\n\n      if (currentBinding.type !== \"checkbox\" && currentBinding.type !== \"radio\") {\n        const target = event.target as FormControl;\n        currentBinding.formStore.setField(currentBinding.name, target.value, target, event);\n        const formattedValue = currentBinding.formStore.formatValue(\n          currentBinding.name,\n          currentBinding.formStore.state[currentBinding.name],\n          target\n        );\n        setControlValue(target, formattedValue);\n      }\n\n      if (currentBinding.onInput) {\n        currentBinding.onInput(event);\n      }\n    };\n\n    control.onchange = (event: Event) => {\n      const currentBinding = withBinding[controlBindingKey];\n      if (!currentBinding) {\n        return;\n      }\n\n      const target = event.target as FormControl;\n      if (currentBinding.type === \"checkbox\") {\n        currentBinding.formStore.setField(currentBinding.name, Boolean(target.checked), target, event);\n      } else if (currentBinding.type === \"radio\") {\n        currentBinding.formStore.setField(currentBinding.name, target.value, target, event);\n      }\n\n      if (currentBinding.onChange) {\n        currentBinding.onChange(event);\n      }\n    };\n  }\n\n  withBinding[controlBindingKey]!.formStore = formStore;\n  withBinding[controlBindingKey]!.name = name;\n  withBinding[controlBindingKey]!.type = type;\n}\n\nfunction syncSubmitButtons(formDom: FormNode, formStore: FormStore<FormState>) {\n  const submitters = getSubmitters(formDom);\n  for (const submitter of submitters) {\n    submitter.disabled = formStore.isInflight;\n  }\n}\n\ndirective(\"form\", (formStore: FormStore<FormState>, vnode: VnodeWithDom) => {\n  const formDom = vnode.dom as unknown as FormNode;\n  if (!formDom || getTagName(formDom) !== \"FORM\") {\n    return;\n  }\n\n  const withBinding = formDom as FormNode & { [formBindingKey]?: FormBinding };\n  if (!withBinding[formBindingKey]) {\n    const binding: FormBinding = {\n      formStore,\n      onSubmit: formDom.onsubmit || null\n    };\n\n    withBinding[formBindingKey] = binding;\n\n    formDom.onsubmit = async (event: Event) => {\n      const currentBinding = withBinding[formBindingKey];\n      if (!currentBinding) {\n        return;\n      }\n\n      const success = await currentBinding.formStore.submit(event);\n      if (!success) {\n        event.preventDefault();\n      }\n\n      if (currentBinding.onSubmit) {\n        await currentBinding.onSubmit(event);\n      }\n    };\n  }\n\n  withBinding[formBindingKey]!.formStore = formStore;\n\n  const controls = getControls(formDom);\n  for (const control of controls) {\n    bindControl(formStore, control);\n  }\n\n  syncSubmitButtons(formDom, formStore);\n});\n\ndirective(\"field\", (formStore: FormStore<FormState>, vnode: VnodeWithDom) => {\n  const control = vnode.dom as unknown as FormControl;\n  bindControl(formStore, control);\n});\n", "// lib/utils.ts\nvar ValidationError = class extends Error {\n  message;\n  item;\n  keyword;\n  cause;\n  schemaPath = \"\";\n  instancePath = \"\";\n  data;\n  schema;\n  _getCause(pointer = \"#\", instancePointer = \"#\") {\n    let schemaPath = `${pointer}/${this.keyword}`;\n    let instancePath = `${instancePointer}`;\n    if (typeof this.item !== \"undefined\") {\n      if (typeof this.item === \"string\" && this.item in this.schema) {\n        schemaPath += `/${this.item}`;\n      }\n      instancePath += `/${this.item}`;\n    }\n    this.instancePath = instancePath;\n    this.schemaPath = schemaPath;\n    if (!this.cause || !(this.cause instanceof ValidationError)) {\n      return this;\n    }\n    return this.cause._getCause(schemaPath, instancePath);\n  }\n  getCause() {\n    return this._getCause();\n  }\n  _getTree() {\n    const tree = {\n      message: this.message,\n      keyword: this.keyword,\n      item: this.item,\n      schemaPath: this.schemaPath,\n      instancePath: this.instancePath,\n      data: this.data\n    };\n    if (this.cause) {\n      tree.cause = this.cause._getTree();\n    }\n    return tree;\n  }\n  getTree() {\n    this.getCause();\n    return this._getTree();\n  }\n  getPath() {\n    const cause = this.getCause();\n    return {\n      schemaPath: cause.schemaPath,\n      instancePath: cause.instancePath\n    };\n  }\n};\nvar FAIL_FAST_DEFINE_ERROR = () => true;\nfunction getDefinedErrorFunctionForKey(key, schema, failFast) {\n  if (failFast) {\n    return FAIL_FAST_DEFINE_ERROR;\n  }\n  const KeywordError = new ValidationError(`Invalid ${key}`);\n  KeywordError.keyword = key;\n  KeywordError.schema = schema;\n  const defineError = (message, options = {}) => {\n    KeywordError.message = message;\n    KeywordError.item = options.item;\n    KeywordError.cause = options.cause && options.cause !== true ? options.cause : void 0;\n    KeywordError.data = options.data;\n    return KeywordError;\n  };\n  return getNamedFunction(\n    `defineError_${key}`,\n    defineError\n  );\n}\nfunction hasChanged(prev, current) {\n  if (Array.isArray(prev)) {\n    if (Array.isArray(current) === false) {\n      return true;\n    }\n    if (prev.length !== current.length) {\n      return true;\n    }\n    for (let i = 0; i < current.length; i++) {\n      if (hasChanged(prev[i], current[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (typeof prev === \"object\" && prev !== null) {\n    if (typeof current !== \"object\" || current === null) {\n      return true;\n    }\n    for (const key in current) {\n      if (hasChanged(prev[key], current[key])) {\n        return true;\n      }\n    }\n    for (const key in prev) {\n      if (hasChanged(prev[key], current[key])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return Object.is(prev, current) === false;\n}\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nfunction areCloseEnough(a, b, epsilon = 1e-15) {\n  return Math.abs(a - b) <= epsilon * Math.max(Math.abs(a), Math.abs(b));\n}\nfunction deepClone(obj, cloneClassInstances = false, seen = /* @__PURE__ */ new WeakMap()) {\n  if (typeof obj === \"undefined\" || obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (seen.has(obj)) {\n    return seen.get(obj);\n  }\n  let clone;\n  if (typeof structuredClone === \"function\") {\n    clone = structuredClone(obj);\n    seen.set(obj, clone);\n    return clone;\n  }\n  switch (true) {\n    case Array.isArray(obj): {\n      clone = [];\n      seen.set(obj, clone);\n      for (let i = 0, l = obj.length; i < l; i++) {\n        clone[i] = deepClone(obj[i], cloneClassInstances, seen);\n      }\n      return clone;\n    }\n    case obj instanceof Date: {\n      clone = new Date(obj.getTime());\n      seen.set(obj, clone);\n      return clone;\n    }\n    case obj instanceof RegExp: {\n      clone = new RegExp(obj.source, obj.flags);\n      seen.set(obj, clone);\n      return clone;\n    }\n    case obj instanceof Map: {\n      clone = /* @__PURE__ */ new Map();\n      seen.set(obj, clone);\n      for (const [key, value] of obj.entries()) {\n        clone.set(\n          deepClone(key, cloneClassInstances, seen),\n          deepClone(value, cloneClassInstances, seen)\n        );\n      }\n      return clone;\n    }\n    case obj instanceof Set: {\n      clone = /* @__PURE__ */ new Set();\n      seen.set(obj, clone);\n      for (const value of obj.values()) {\n        clone.add(deepClone(value, cloneClassInstances, seen));\n      }\n      return clone;\n    }\n    case obj instanceof ArrayBuffer: {\n      clone = obj.slice(0);\n      seen.set(obj, clone);\n      return clone;\n    }\n    case ArrayBuffer.isView(obj): {\n      clone = new obj.constructor(obj.buffer.slice(0));\n      seen.set(obj, clone);\n      return clone;\n    }\n    case (typeof Buffer !== \"undefined\" && obj instanceof Buffer): {\n      clone = Buffer.from(obj);\n      seen.set(obj, clone);\n      return clone;\n    }\n    case obj instanceof Error: {\n      clone = new obj.constructor(obj.message);\n      seen.set(obj, clone);\n      break;\n    }\n    case (obj instanceof Promise || obj instanceof WeakMap || obj instanceof WeakSet): {\n      clone = obj;\n      seen.set(obj, clone);\n      return clone;\n    }\n    case (obj.constructor && obj.constructor !== Object): {\n      if (!cloneClassInstances) {\n        clone = obj;\n        seen.set(obj, clone);\n        return clone;\n      }\n      clone = Object.create(Object.getPrototypeOf(obj));\n      seen.set(obj, clone);\n      break;\n    }\n    default: {\n      clone = {};\n      seen.set(obj, clone);\n      const keys = Reflect.ownKeys(obj);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        clone[key] = deepClone(\n          obj[key],\n          cloneClassInstances,\n          seen\n        );\n      }\n      return clone;\n    }\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  for (const key of Reflect.ownKeys(descriptors)) {\n    const descriptor = descriptors[key];\n    if (\"value\" in descriptor) {\n      descriptor.value = deepClone(descriptor.value, cloneClassInstances, seen);\n    }\n    Object.defineProperty(clone, key, descriptor);\n  }\n  return clone;\n}\nfunction isCompiledSchema(subSchema) {\n  return isObject(subSchema) && \"$validate\" in subSchema;\n}\nfunction getNamedFunction(name, fn) {\n  return Object.defineProperty(fn, \"name\", { value: name });\n}\nfunction resolvePath(root, path) {\n  if (!path || path === \"#\") {\n    return root;\n  }\n  if (path.startsWith(\"#/\")) {\n    const parts = path.split(\"/\").slice(1);\n    let current = root;\n    for (const part of parts) {\n      const decodedUriPart = decodeURIComponent(part);\n      const key = decodedUriPart.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n      if (current && typeof current === \"object\" && key in current) {\n        current = current[key];\n      } else {\n        return;\n      }\n    }\n    return current;\n  }\n  if (!path.includes(\"#\")) {\n    if (root.definitions && root.definitions[path]) {\n      return root.definitions[path];\n    }\n    if (root.defs && root.defs[path]) {\n      return root.defs[path];\n    }\n    if (root.$id && typeof root.$id === \"string\") {\n      if (root.$id === path || root.$id.endsWith(\"/\" + path)) {\n        return root;\n      }\n    }\n  }\n  return;\n}\n\n// lib/formats.ts\nvar UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nvar DURATION_REGEX = /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?)(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/;\nvar DATE_TIME_REGEX = /^(\\d{4})-(0[0-9]|1[0-2])-(\\d{2})T(0[0-9]|1\\d|2[0-3]):([0-5]\\d):((?:[0-5]\\d|60))(?:.\\d+)?(?:([+-])(0[0-9]|1\\d|2[0-3]):([0-5]\\d)|Z)?$/i;\nvar URI_REGEX = /^[a-zA-Z][a-zA-Z0-9+\\-.]*:[^\\s]*$/;\nvar EMAIL_REGEX = /^(?!\\.)(?!.*\\.$)[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i;\nvar IPV4_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$/;\nvar IPV6_REGEX = /(?:\\s+|:::+|^\\w{5,}|\\w{5}$|^:{1}\\w|\\w:{1}$)/;\nvar IPV6_SHORT_REGEX = /^[0-9a-fA-F:.]*$/;\nvar IPV6_FULL_REGEX = /^(?:(?:[0-9a-fA-F]{1,4}:){7}(?:[0-9a-fA-F]{1,4}|:))$/;\nvar IPV6_INVALID_CHAR_REGEX = /(?:[0-9a-fA-F]{5,}|\\D[0-9a-fA-F]{3}:)/;\nvar IPV6_FAST_FAIL_REGEX = /^(?:(?:(?:[0-9a-fA-F]{1,4}(?::|$)){1,6}))|(?:::(?:[0-9a-fA-F]{1,4})){0,5}$/;\nvar HOSTNAME_REGEX = /^[a-z0-9][a-z0-9-]{0,62}(?:\\.[a-z0-9][a-z0-9-]{0,62})*[a-z0-9]$/i;\nvar DATE_REGEX = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nvar JSON_POINTER_REGEX = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER_REGEX = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nvar TIME_REGEX = /^([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)(\\.\\d+)?(Z|([+-])([01]\\d|2[0-3]):([0-5]\\d))$/;\nvar URI_REFERENCE_REGEX = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#((?![^#]*\\\\)[^#]*))?/i;\nvar URI_TEMPLATE_REGEX = /^(?:[^{}]|\\{[^}]+\\})*$/;\nvar IRI_REGEX = /^[a-zA-Z][a-zA-Z0-9+\\-.]*:[^\\s]*$/;\nvar IRI_REFERENCE_REGEX = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#((?![^#]*\\\\)[^#]*))?/i;\nvar IDN_EMAIL_REGEX = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\nvar IDN_HOSTNAME_REGEX = /^[^\\s!@#$%^&*()_+\\=\\[\\]{};':\"\\\\|,<>\\/?]+$/;\nvar BACK_SLASH_REGEX = /\\\\/;\nvar DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar Formats = {\n  [\"date-time\"](data) {\n    const match = data.match(DATE_TIME_REGEX);\n    if (!match) {\n      return false;\n    }\n    const [, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr] = match;\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    const day = Number(dayStr);\n    const hour = Number(hourStr);\n    const minute = Number(minuteStr);\n    const second = Number(secondStr);\n    if (month < 1 || month > 12) {\n      return false;\n    }\n    if (day < 1) {\n      return false;\n    }\n    const maxDays = month === 2 ? year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : 28 : DAYS_IN_MONTH[month - 1];\n    if (!maxDays || day > maxDays) {\n      return false;\n    }\n    if (second === 60 && (minute !== 59 || hour !== 23)) {\n      return false;\n    }\n    return true;\n  },\n  uri(data) {\n    return URI_REGEX.test(data);\n  },\n  email(data) {\n    return EMAIL_REGEX.test(data);\n  },\n  ipv4(data) {\n    return IPV4_REGEX.test(data);\n  },\n  // ipv6: isMyIpValid({ version: 6 }),\n  ipv6(data) {\n    if (data === \"::\") {\n      return true;\n    }\n    if (data.indexOf(\":\") === -1 || IPV6_REGEX.test(data)) {\n      return false;\n    }\n    const hasIpv4 = data.indexOf(\".\") !== -1;\n    let addressParts = data;\n    if (hasIpv4) {\n      addressParts = data.split(\":\");\n      const ipv4Part = addressParts.pop();\n      if (!IPV4_REGEX.test(ipv4Part)) {\n        return false;\n      }\n    }\n    const isShortened = data.indexOf(\"::\") !== -1;\n    const ipv6Part = hasIpv4 ? addressParts.join(\":\") : data;\n    if (isShortened) {\n      if (ipv6Part.split(\"::\").length - 1 > 1) {\n        return false;\n      }\n      if (!IPV6_SHORT_REGEX.test(ipv6Part)) {\n        return false;\n      }\n      return IPV6_FAST_FAIL_REGEX.test(ipv6Part);\n    }\n    const isIpv6Valid = IPV6_FULL_REGEX.test(ipv6Part);\n    const hasInvalidChar = IPV6_INVALID_CHAR_REGEX.test(ipv6Part);\n    if (hasIpv4) {\n      return isIpv6Valid || !hasInvalidChar;\n    }\n    return isIpv6Valid && !hasInvalidChar;\n  },\n  hostname(data) {\n    return HOSTNAME_REGEX.test(data);\n  },\n  date(data) {\n    const match = DATE_REGEX.exec(data);\n    if (!match) {\n      return false;\n    }\n    const [, yearStr, monthStr, dayStr] = match;\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    const day = Number(dayStr);\n    if (month < 1 || month > 12) {\n      return false;\n    }\n    if (day < 1) {\n      return false;\n    }\n    const maxDays = month === 2 ? year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : 28 : DAYS_IN_MONTH[month - 1];\n    return !!maxDays && day <= maxDays;\n  },\n  regex(data) {\n    try {\n      new RegExp(data);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n  \"json-pointer\"(data) {\n    if (data === \"\") {\n      return true;\n    }\n    return JSON_POINTER_REGEX.test(data);\n  },\n  \"relative-json-pointer\"(data) {\n    if (data === \"\") {\n      return true;\n    }\n    return RELATIVE_JSON_POINTER_REGEX.test(data);\n  },\n  time(data) {\n    return TIME_REGEX.test(data);\n  },\n  \"uri-reference\"(data) {\n    if (BACK_SLASH_REGEX.test(data)) {\n      return false;\n    }\n    return URI_REFERENCE_REGEX.test(data);\n  },\n  \"uri-template\"(data) {\n    return URI_TEMPLATE_REGEX.test(data);\n  },\n  duration(data) {\n    return DURATION_REGEX.test(data);\n  },\n  uuid(data) {\n    return UUID_REGEX.test(data);\n  },\n  // IRI is like URI but allows Unicode. We reuse a permissive logic.\n  iri(data) {\n    return IRI_REGEX.test(data);\n  },\n  \"iri-reference\"(data) {\n    if (BACK_SLASH_REGEX.test(data)) {\n      return false;\n    }\n    return IRI_REFERENCE_REGEX.test(data);\n  },\n  // Best-effort structural validation for IDN (no punycode/tables)\n  \"idn-email\"(data) {\n    return IDN_EMAIL_REGEX.test(data);\n  },\n  \"idn-hostname\"(data) {\n    return IDN_HOSTNAME_REGEX.test(data);\n  }\n};\n\n// lib/types.ts\nvar Types = {\n  object(data) {\n    return isObject(data);\n  },\n  array(data) {\n    return Array.isArray(data);\n  },\n  string(data) {\n    return typeof data === \"string\";\n  },\n  number(data) {\n    return typeof data === \"number\";\n  },\n  integer(data) {\n    return typeof data === \"number\" && data % 1 === 0;\n  },\n  boolean(data) {\n    return typeof data === \"boolean\";\n  },\n  null(data) {\n    return data === null;\n  },\n  // Not implemented yet\n  timestamp: false,\n  int8: false,\n  unit8: false,\n  int16: false,\n  unit16: false,\n  int32: false,\n  unit32: false,\n  float32: false,\n  float64: false\n};\n\n// lib/keywords/array-keywords.ts\nvar ArrayKeywords = {\n  // lib/keywords/array-keywords.ts\n  items(schema, data, defineError) {\n    if (!Array.isArray(data)) {\n      return;\n    }\n    const schemaItems = schema.items;\n    const dataLength = data.length;\n    if (typeof schemaItems === \"boolean\") {\n      if (schemaItems === false && dataLength > 0) {\n        return defineError(\"Array items are not allowed\", { data });\n      }\n      return;\n    }\n    if (Array.isArray(schemaItems)) {\n      const schemaItemsLength = schemaItems.length;\n      const itemsLength = schemaItemsLength < dataLength ? schemaItemsLength : dataLength;\n      for (let i = 0; i < itemsLength; i++) {\n        const schemaItem = schemaItems[i];\n        if (typeof schemaItem === \"boolean\") {\n          if (schemaItem === false && data[i] !== void 0) {\n            return defineError(\"Array item is not allowed\", {\n              item: i,\n              data: data[i]\n            });\n          }\n          continue;\n        }\n        const validate2 = schemaItem && schemaItem.$validate;\n        if (typeof validate2 === \"function\") {\n          const error = validate2(data[i]);\n          if (error) {\n            return defineError(\"Array item is invalid\", {\n              item: i,\n              cause: error,\n              data: data[i]\n            });\n          }\n        }\n      }\n      return;\n    }\n    const validate = schemaItems && schemaItems.$validate;\n    if (typeof validate !== \"function\") {\n      return;\n    }\n    for (let i = 0; i < dataLength; i++) {\n      const error = validate(data[i]);\n      if (error) {\n        return defineError(\"Array item is invalid\", {\n          item: i,\n          cause: error,\n          data: data[i]\n        });\n      }\n    }\n  },\n  elements(schema, data, defineError) {\n    if (!Array.isArray(data)) {\n      return;\n    }\n    const elementsSchema = schema.elements;\n    const validate = elementsSchema && elementsSchema.$validate;\n    if (typeof validate !== \"function\") {\n      return;\n    }\n    for (let i = 0; i < data.length; i++) {\n      const error = validate(data[i]);\n      if (error) {\n        return defineError(\"Array item is invalid\", {\n          item: i,\n          cause: error,\n          data: data[i]\n        });\n      }\n    }\n  },\n  minItems(schema, data, defineError) {\n    if (!Array.isArray(data) || data.length >= schema.minItems) {\n      return;\n    }\n    return defineError(\"Array is too short\", { data });\n  },\n  maxItems(schema, data, defineError) {\n    if (!Array.isArray(data) || data.length <= schema.maxItems) {\n      return;\n    }\n    return defineError(\"Array is too long\", { data });\n  },\n  additionalItems(schema, data, defineError) {\n    if (!schema.items || isObject(schema.items)) {\n      return;\n    }\n    if (schema.additionalItems === false) {\n      if (data.length > schema.items.length) {\n        return defineError(\"Array is too long\", { data });\n      }\n      return;\n    }\n    if (isObject(schema.additionalItems)) {\n      if (isCompiledSchema(schema.additionalItems)) {\n        for (let i = schema.items.length; i < data.length; i++) {\n          const error = schema.additionalItems.$validate(data[i]);\n          if (error) {\n            return defineError(\"Array item is invalid\", {\n              item: i,\n              cause: error,\n              data: data[i]\n            });\n          }\n        }\n        return;\n      }\n      return;\n    }\n    return;\n  },\n  uniqueItems(schema, data, defineError) {\n    if (!Array.isArray(data) || !schema.uniqueItems) {\n      return;\n    }\n    const len = data.length;\n    if (len <= 1) {\n      return;\n    }\n    const primitiveSeen = /* @__PURE__ */ new Set();\n    for (let i = 0; i < len; i++) {\n      const item = data[i];\n      const type = typeof item;\n      if (item === null || type === \"string\" || type === \"number\" || type === \"boolean\") {\n        if (primitiveSeen.has(item)) {\n          return defineError(\"Array items are not unique\", { data: item });\n        }\n        primitiveSeen.add(item);\n        continue;\n      }\n      if (item && typeof item === \"object\") {\n        for (let j = 0; j < i; j++) {\n          const prev = data[j];\n          if (prev && typeof prev === \"object\" && !hasChanged(prev, item)) {\n            return defineError(\"Array items are not unique\", { data: item });\n          }\n        }\n      }\n    }\n  },\n  contains(schema, data, defineError) {\n    if (!Array.isArray(data)) {\n      return;\n    }\n    if (typeof schema.contains === \"boolean\") {\n      if (schema.contains) {\n        if (data.length === 0) {\n          return defineError(\"Array must contain at least one item\", { data });\n        }\n        return;\n      }\n      return defineError(\"Array must not contain any items\", { data });\n    }\n    for (let i = 0; i < data.length; i++) {\n      const error = schema.contains.$validate(data[i]);\n      if (!error) {\n        return;\n      }\n      continue;\n    }\n    return defineError(\"Array must contain at least one item\", { data });\n  }\n};\n\n// lib/keywords/number-keywords.ts\nvar NumberKeywords = {\n  minimum(schema, data, defineError, instance) {\n    if (typeof data !== \"number\") {\n      return;\n    }\n    let min = schema.minimum;\n    if (typeof schema.exclusiveMinimum === \"number\") {\n      min = schema.exclusiveMinimum + 1e-15;\n    } else if (schema.exclusiveMinimum === true) {\n      min += 1e-15;\n    }\n    if (data < min) {\n      return defineError(\"Value is less than the minimum\", { data });\n    }\n    return;\n  },\n  maximum(schema, data, defineError, instance) {\n    if (typeof data !== \"number\") {\n      return;\n    }\n    let max = schema.maximum;\n    if (typeof schema.exclusiveMaximum === \"number\") {\n      max = schema.exclusiveMaximum - 1e-15;\n    } else if (schema.exclusiveMaximum === true) {\n      max -= 1e-15;\n    }\n    if (data > max) {\n      return defineError(\"Value is greater than the maximum\", { data });\n    }\n    return;\n  },\n  multipleOf(schema, data, defineError, instance) {\n    if (typeof data !== \"number\") {\n      return;\n    }\n    const quotient = data / schema.multipleOf;\n    if (!isFinite(quotient)) {\n      return;\n    }\n    if (!areCloseEnough(quotient, Math.round(quotient))) {\n      return defineError(\"Value is not a multiple of the multipleOf\", { data });\n    }\n    return;\n  },\n  exclusiveMinimum(schema, data, defineError, instance) {\n    if (typeof data !== \"number\" || typeof schema.exclusiveMinimum !== \"number\" || \"minimum\" in schema) {\n      return;\n    }\n    if (data <= schema.exclusiveMinimum + 1e-15) {\n      return defineError(\"Value is less than or equal to the exclusiveMinimum\");\n    }\n    return;\n  },\n  exclusiveMaximum(schema, data, defineError, instance) {\n    if (typeof data !== \"number\" || typeof schema.exclusiveMaximum !== \"number\" || \"maximum\" in schema) {\n      return;\n    }\n    if (data >= schema.exclusiveMaximum) {\n      return defineError(\n        \"Value is greater than or equal to the exclusiveMaximum\",\n        { data }\n      );\n    }\n    return;\n  }\n};\n\n// lib/keywords/object-keywords.ts\nvar ObjectKeywords = {\n  required(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    for (let i = 0; i < schema.required.length; i++) {\n      const key = schema.required[i];\n      if (!data.hasOwnProperty(key)) {\n        return defineError(\"Required property is missing\", {\n          item: key,\n          data: data[key]\n        });\n      }\n    }\n    return;\n  },\n  properties(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    let propKeys = schema._propKeys;\n    if (!propKeys) {\n      propKeys = Object.keys(schema.properties || {});\n      Object.defineProperty(schema, \"_propKeys\", {\n        value: propKeys,\n        enumerable: false,\n        configurable: false,\n        writable: false\n      });\n    }\n    let requiredKeys = schema._requiredKeys;\n    if (requiredKeys === void 0) {\n      requiredKeys = Array.isArray(schema.required) ? schema.required : null;\n      Object.defineProperty(schema, \"_requiredKeys\", {\n        value: requiredKeys,\n        enumerable: false,\n        configurable: false,\n        writable: false\n      });\n    }\n    const required = requiredKeys || [];\n    for (let i = 0; i < propKeys.length; i++) {\n      const key = propKeys[i];\n      const schemaProp = schema.properties[key];\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        if (required.length && required.indexOf(key) !== -1 && isObject(schemaProp) && \"default\" in schemaProp) {\n          const error = schemaProp.$validate(schemaProp.default);\n          if (error) {\n            return defineError(\"Default property is invalid\", {\n              item: key,\n              cause: error,\n              data: schemaProp.default\n            });\n          }\n          data[key] = deepClone(schemaProp.default);\n        }\n        continue;\n      }\n      if (typeof schemaProp === \"boolean\") {\n        if (schemaProp === false) {\n          return defineError(\"Property is not allowed\", {\n            item: key,\n            data: data[key]\n          });\n        }\n        continue;\n      }\n      if (schemaProp && \"$validate\" in schemaProp) {\n        const error = schemaProp.$validate(data[key]);\n        if (error) {\n          return defineError(\"Property is invalid\", {\n            item: key,\n            cause: error,\n            data: data[key]\n          });\n        }\n      }\n    }\n    return;\n  },\n  values(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    const valueSchema = schema.values;\n    const validate = valueSchema && valueSchema.$validate;\n    if (typeof validate !== \"function\") {\n      return;\n    }\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const error = validate(data[key]);\n      if (error) {\n        return defineError(\"Property is invalid\", {\n          item: key,\n          cause: error,\n          data: data[key]\n        });\n      }\n    }\n  },\n  maxProperties(schema, data, defineError) {\n    if (!isObject(data) || Object.keys(data).length <= schema.maxProperties) {\n      return;\n    }\n    return defineError(\"Too many properties\", { data });\n  },\n  minProperties(schema, data, defineError) {\n    if (!isObject(data) || Object.keys(data).length >= schema.minProperties) {\n      return;\n    }\n    return defineError(\"Too few properties\", { data });\n  },\n  additionalProperties(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    const keys = Object.keys(data);\n    let apIsCompiled = schema._apIsCompiled;\n    if (apIsCompiled === void 0) {\n      apIsCompiled = isCompiledSchema(schema.additionalProperties);\n      Object.defineProperty(schema, \"_apIsCompiled\", {\n        value: apIsCompiled,\n        enumerable: false\n      });\n    }\n    let patternList = schema._patternPropertiesList;\n    if (schema.patternProperties && !patternList) {\n      patternList = [];\n      for (const pattern in schema.patternProperties) {\n        patternList.push({\n          regex: new RegExp(pattern, \"u\"),\n          key: pattern\n        });\n      }\n      Object.defineProperty(schema, \"_patternPropertiesList\", {\n        value: patternList,\n        enumerable: false\n      });\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (schema.properties && schema.properties.hasOwnProperty(key)) {\n        continue;\n      }\n      if (patternList && patternList.length) {\n        let match = false;\n        for (let j = 0; j < patternList.length; j++) {\n          if (patternList[j].regex.test(key)) {\n            match = true;\n            break;\n          }\n        }\n        if (match) {\n          continue;\n        }\n      }\n      if (schema.additionalProperties === false) {\n        return defineError(\"Additional properties are not allowed\", {\n          item: key,\n          data: data[key]\n        });\n      }\n      if (apIsCompiled && isCompiledSchema(schema.additionalProperties)) {\n        const error = schema.additionalProperties.$validate(data[key]);\n        if (error) {\n          return defineError(\"Additional properties are invalid\", {\n            item: key,\n            cause: error,\n            data: data[key]\n          });\n        }\n      }\n    }\n    return;\n  },\n  patternProperties(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    let patternList = schema._patternPropertiesList;\n    if (!patternList) {\n      patternList = [];\n      const patterns = Object.keys(schema.patternProperties || {});\n      for (let i = 0; i < patterns.length; i++) {\n        const pattern = patterns[i];\n        patternList.push({\n          regex: new RegExp(pattern, \"u\"),\n          key: pattern\n        });\n      }\n      Object.defineProperty(schema, \"_patternPropertiesList\", {\n        value: patternList,\n        enumerable: false\n      });\n    }\n    const dataKeys = Object.keys(data);\n    for (let p = 0; p < patternList.length; p++) {\n      const { regex, key: patternKey } = patternList[p];\n      const schemaProp = schema.patternProperties[patternKey];\n      if (typeof schemaProp === \"boolean\") {\n        if (schemaProp === false) {\n          for (let i = 0; i < dataKeys.length; i++) {\n            const key = dataKeys[i];\n            if (regex.test(key)) {\n              return defineError(\"Property is not allowed\", {\n                item: key,\n                data: data[key]\n              });\n            }\n          }\n        }\n        continue;\n      }\n      if (\"$validate\" in schemaProp) {\n        for (let i = 0; i < dataKeys.length; i++) {\n          const key = dataKeys[i];\n          if (regex.test(key)) {\n            const error = schemaProp.$validate(data[key]);\n            if (error) {\n              return defineError(\"Property is invalid\", {\n                item: key,\n                cause: error,\n                data: data[key]\n              });\n            }\n          }\n        }\n      }\n    }\n    return;\n  },\n  propertyNames(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    const pn = schema.propertyNames;\n    if (typeof pn === \"boolean\") {\n      if (pn === false && Object.keys(data).length > 0) {\n        return defineError(\"Properties are not allowed\", { data });\n      }\n      return;\n    }\n    const validate = pn && pn.$validate;\n    if (typeof validate !== \"function\") {\n      return;\n    }\n    for (const key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      const error = validate(key);\n      if (error) {\n        return defineError(\"Property name is invalid\", {\n          item: key,\n          cause: error,\n          data: data[key]\n        });\n      }\n    }\n  },\n  dependencies(schema, data, defineError) {\n    if (!isObject(data)) {\n      return;\n    }\n    for (const key in schema.dependencies) {\n      if (key in data === false) {\n        continue;\n      }\n      const dependency = schema.dependencies[key];\n      if (Array.isArray(dependency)) {\n        for (let i = 0; i < dependency.length; i++) {\n          if (!(dependency[i] in data)) {\n            return defineError(\"Dependency is not satisfied\", {\n              item: i,\n              data: dependency[i]\n            });\n          }\n        }\n        continue;\n      }\n      if (typeof dependency === \"boolean\") {\n        if (dependency) {\n          continue;\n        }\n        return defineError(\"Dependency is not satisfied\", { data: dependency });\n      }\n      if (typeof dependency === \"string\") {\n        if (dependency in data) {\n          continue;\n        }\n        return defineError(\"Dependency is not satisfied\", { data: dependency });\n      }\n      const error = dependency.$validate(data);\n      if (error) {\n        return defineError(\"Dependency is not satisfied\", {\n          cause: error,\n          data\n        });\n      }\n    }\n    return;\n  },\n  // Required by other keywords but not used as a function itself\n  then: false,\n  else: false,\n  default: false,\n  // Not implemented yet\n  definitions: false,\n  $id: false,\n  $schema: false,\n  // Metadata keywords (not used as a function)\n  title: false,\n  description: false,\n  $comment: false,\n  examples: false,\n  contentMediaType: false,\n  contentEncoding: false,\n  // Not supported Open API keywords\n  discriminator: false,\n  nullable: false\n};\n\n// lib/keywords/other-keywords.ts\nvar OtherKeywords = {\n  enum(schema, data, defineError) {\n    const list = schema.enum;\n    for (let i = 0; i < list.length; i++) {\n      const enumItem = list[i];\n      if (enumItem === data) {\n        return;\n      }\n      if (enumItem !== null && data !== null && typeof enumItem === \"object\" && typeof data === \"object\" && !hasChanged(enumItem, data)) {\n        return;\n      }\n    }\n    return defineError(\"Value is not one of the allowed values\", { data });\n  },\n  allOf(schema, data, defineError) {\n    for (let i = 0; i < schema.allOf.length; i++) {\n      if (isObject(schema.allOf[i])) {\n        if (\"$validate\" in schema.allOf[i]) {\n          const error = schema.allOf[i].$validate(data);\n          if (error) {\n            return defineError(\"Value is not valid\", { cause: error, data });\n          }\n        }\n        continue;\n      }\n      if (typeof schema.allOf[i] === \"boolean\") {\n        if (Boolean(data) !== schema.allOf[i]) {\n          return defineError(\"Value is not valid\", { data });\n        }\n        continue;\n      }\n      if (data !== schema.allOf[i]) {\n        return defineError(\"Value is not valid\", { data });\n      }\n    }\n    return;\n  },\n  anyOf(schema, data, defineError) {\n    for (let i = 0; i < schema.anyOf.length; i++) {\n      if (isObject(schema.anyOf[i])) {\n        if (\"$validate\" in schema.anyOf[i]) {\n          const error = schema.anyOf[i].$validate(data);\n          if (!error) {\n            return;\n          }\n          continue;\n        }\n        return;\n      } else {\n        if (typeof schema.anyOf[i] === \"boolean\") {\n          if (Boolean(data) === schema.anyOf[i]) {\n            return;\n          }\n        }\n        if (data === schema.anyOf[i]) {\n          return;\n        }\n      }\n    }\n    return defineError(\"Value is not valid\", { data });\n  },\n  oneOf(schema, data, defineError) {\n    const list = schema.oneOf;\n    let validCount = 0;\n    for (let i = 0; i < list.length; i++) {\n      const sub = list[i];\n      if (isObject(sub)) {\n        if (\"$validate\" in sub) {\n          const error = sub.$validate(data);\n          if (!error) {\n            validCount++;\n            if (validCount > 1) {\n              return defineError(\"Value is not valid\", { data });\n            }\n          }\n          continue;\n        }\n        validCount++;\n        if (validCount > 1) {\n          return defineError(\"Value is not valid\", { data });\n        }\n        continue;\n      }\n      if (typeof sub === \"boolean\") {\n        if (Boolean(data) === sub) {\n          validCount++;\n          if (validCount > 1) {\n            return defineError(\"Value is not valid\", { data });\n          }\n        }\n        continue;\n      }\n      if (data === sub) {\n        validCount++;\n        if (validCount > 1) {\n          return defineError(\"Value is not valid\", { data });\n        }\n      }\n    }\n    if (validCount === 1) {\n      return;\n    }\n    return defineError(\"Value is not valid\", { data });\n  },\n  const(schema, data, defineError) {\n    if (data === schema.const) {\n      return;\n    }\n    if (isObject(data) && isObject(schema.const) && !hasChanged(data, schema.const) || Array.isArray(data) && Array.isArray(schema.const) && !hasChanged(data, schema.const)) {\n      return;\n    }\n    return defineError(\"Value is not valid\", { data });\n  },\n  if(schema, data) {\n    if (\"then\" in schema === false && \"else\" in schema === false) {\n      return;\n    }\n    if (typeof schema.if === \"boolean\") {\n      if (schema.if) {\n        if (isCompiledSchema(schema.then)) {\n          return schema.then.$validate(data);\n        }\n      } else if (isCompiledSchema(schema.else)) {\n        return schema.else.$validate(data);\n      }\n      return;\n    }\n    if (!isCompiledSchema(schema.if)) {\n      return;\n    }\n    const error = schema.if.$validate(data);\n    if (!error) {\n      if (isCompiledSchema(schema.then)) {\n        return schema.then.$validate(data);\n      }\n      return;\n    } else {\n      if (isCompiledSchema(schema.else)) {\n        return schema.else.$validate(data);\n      }\n      return;\n    }\n  },\n  not(schema, data, defineError) {\n    if (typeof schema.not === \"boolean\") {\n      if (schema.not) {\n        return defineError(\"Value is not valid\", { data });\n      }\n      return;\n    }\n    if (isObject(schema.not)) {\n      if (\"$validate\" in schema.not) {\n        const error = schema.not.$validate(data);\n        if (!error) {\n          return defineError(\"Value is not valid\", { cause: error, data });\n        }\n        return;\n      }\n      return defineError(\"Value is not valid\", { data });\n    }\n    return defineError(\"Value is not valid\", { data });\n  },\n  $ref(schema, data, defineError, instance) {\n    if (schema._resolvedRef) {\n      return schema._resolvedRef(data);\n    }\n    const refPath = schema.$ref;\n    let targetSchema = instance.getSchemaRef(refPath);\n    if (!targetSchema) {\n      targetSchema = instance.getSchemaById(refPath);\n    }\n    if (!targetSchema) {\n      return defineError(`Missing reference: ${refPath}`);\n    }\n    if (!targetSchema.$validate) {\n      return;\n    }\n    schema._resolvedRef = targetSchema.$validate;\n    return schema._resolvedRef(data);\n  }\n};\n\n// lib/keywords/string-keywords.ts\nvar StringKeywords = {\n  minLength(schema, data, defineError) {\n    if (typeof data !== \"string\" || data.length >= schema.minLength) {\n      return;\n    }\n    return defineError(\"Value is shorter than the minimum length\", { data });\n  },\n  maxLength(schema, data, defineError) {\n    if (typeof data !== \"string\" || data.length <= schema.maxLength) {\n      return;\n    }\n    return defineError(\"Value is longer than the maximum length\", { data });\n  },\n  pattern(schema, data, defineError) {\n    if (typeof data !== \"string\") {\n      return;\n    }\n    let patternRegexp = schema._patternRegexp;\n    if (!patternRegexp) {\n      try {\n        patternRegexp = new RegExp(schema.pattern, \"u\");\n        Object.defineProperty(schema, \"_patternRegexp\", {\n          value: patternRegexp,\n          enumerable: false,\n          configurable: false,\n          writable: false\n        });\n      } catch (error) {\n        return defineError(\"Invalid regular expression\", {\n          data,\n          cause: error\n        });\n      }\n    }\n    if (patternRegexp.test(data)) {\n      return;\n    }\n    return defineError(\"Value does not match the pattern\", { data });\n  },\n  // Take into account that if we receive a format that is not defined, we\n  // will not throw an error, we just ignore it.\n  format(schema, data, defineError, instance) {\n    if (typeof data !== \"string\") {\n      return;\n    }\n    let formatValidate = schema._formatValidate;\n    if (formatValidate === void 0) {\n      formatValidate = instance.getFormat(schema.format);\n      Object.defineProperty(schema, \"_formatValidate\", {\n        value: formatValidate,\n        enumerable: false,\n        configurable: false,\n        writable: false\n      });\n    }\n    if (!formatValidate || formatValidate(data)) {\n      return;\n    }\n    return defineError(\"Value does not match the format\", { data });\n  }\n};\n\n// lib/keywords.ts\nvar keywords = {\n  ...ObjectKeywords,\n  ...ArrayKeywords,\n  ...StringKeywords,\n  ...NumberKeywords,\n  ...OtherKeywords\n};\n\n// lib/index.ts\nvar SchemaShield = class {\n  types = {};\n  formats = {};\n  keywords = {};\n  immutable = false;\n  rootSchema = null;\n  idRegistry = /* @__PURE__ */ new Map();\n  failFast = true;\n  constructor({\n    immutable = false,\n    failFast = true\n  } = {}) {\n    this.immutable = immutable;\n    this.failFast = failFast;\n    for (const [type, validator] of Object.entries(Types)) {\n      if (validator) {\n        this.addType(type, validator);\n      }\n    }\n    for (const [keyword, validator] of Object.entries(keywords)) {\n      this.addKeyword(keyword, validator);\n    }\n    for (const [format, validator] of Object.entries(Formats)) {\n      if (validator) {\n        this.addFormat(format, validator);\n      }\n    }\n  }\n  addType(name, validator, overwrite = false) {\n    if (this.types[name] && !overwrite) {\n      throw new ValidationError(`Type \"${name}\" already exists`);\n    }\n    this.types[name] = validator;\n  }\n  getType(type) {\n    return this.types[type];\n  }\n  addFormat(name, validator, overwrite = false) {\n    if (this.formats[name] && !overwrite) {\n      throw new ValidationError(`Format \"${name}\" already exists`);\n    }\n    this.formats[name] = validator;\n  }\n  getFormat(format) {\n    return this.formats[format];\n  }\n  addKeyword(name, validator, overwrite = false) {\n    if (this.keywords[name] && !overwrite) {\n      throw new ValidationError(`Keyword \"${name}\" already exists`);\n    }\n    this.keywords[name] = validator;\n  }\n  getKeyword(keyword) {\n    return this.keywords[keyword];\n  }\n  getSchemaRef(path) {\n    if (!this.rootSchema) {\n      return;\n    }\n    return resolvePath(this.rootSchema, path);\n  }\n  getSchemaById(id) {\n    return this.idRegistry.get(id);\n  }\n  compile(schema) {\n    this.idRegistry.clear();\n    const compiledSchema = this.compileSchema(schema);\n    this.rootSchema = compiledSchema;\n    this.linkReferences(compiledSchema);\n    if (!compiledSchema.$validate) {\n      if (this.isSchemaLike(schema) === false) {\n        throw new ValidationError(\"Invalid schema\");\n      }\n      compiledSchema.$validate = getNamedFunction(\n        \"Validate_Any\",\n        () => {\n        }\n      );\n    }\n    const validate = (data) => {\n      this.rootSchema = compiledSchema;\n      const clonedData = this.immutable ? deepClone(data) : data;\n      const res = compiledSchema.$validate(clonedData);\n      if (res) {\n        return { data: clonedData, error: res, valid: false };\n      }\n      return { data: clonedData, error: null, valid: true };\n    };\n    validate.compiledSchema = compiledSchema;\n    return validate;\n  }\n  compileSchema(schema) {\n    if (!isObject(schema)) {\n      if (schema === true) {\n        schema = { anyOf: [{}] };\n      } else if (schema === false) {\n        schema = { oneOf: [] };\n      } else {\n        schema = { oneOf: [schema] };\n      }\n    }\n    const compiledSchema = deepClone(schema);\n    if (typeof schema.$id === \"string\") {\n      this.idRegistry.set(schema.$id, compiledSchema);\n    }\n    if (\"$ref\" in schema) {\n      const refValidator = this.getKeyword(\"$ref\");\n      if (refValidator) {\n        const defineError = getDefinedErrorFunctionForKey(\n          \"$ref\",\n          schema[\"$ref\"],\n          this.failFast\n        );\n        compiledSchema.$validate = getNamedFunction(\n          \"Validate_Reference\",\n          (data) => refValidator(\n            compiledSchema,\n            data,\n            defineError,\n            this\n          )\n        );\n      }\n      return compiledSchema;\n    }\n    const validators = [];\n    const activeNames = [];\n    if (\"type\" in schema) {\n      const defineTypeError = getDefinedErrorFunctionForKey(\n        \"type\",\n        schema,\n        this.failFast\n      );\n      const types = Array.isArray(schema.type) ? schema.type : schema.type.split(\",\").map((t) => t.trim());\n      const typeFunctions = [];\n      const typeNames = [];\n      for (const type2 of types) {\n        const validator = this.getType(type2);\n        if (validator) {\n          typeFunctions.push(validator);\n          typeNames.push(validator.name);\n        }\n      }\n      if (typeFunctions.length === 0) {\n        throw getDefinedErrorFunctionForKey(\n          \"type\",\n          schema,\n          this.failFast\n        )(\"Invalid type for schema\", { data: schema.type });\n      }\n      let combinedTypeValidator;\n      let typeMethodName = \"\";\n      if (typeFunctions.length === 1) {\n        typeMethodName = typeNames[0];\n        const singleTypeFn = typeFunctions[0];\n        combinedTypeValidator = (data) => {\n          if (!singleTypeFn(data)) {\n            return defineTypeError(\"Invalid type\", { data });\n          }\n        };\n      } else {\n        typeMethodName = typeNames.join(\"_OR_\");\n        combinedTypeValidator = (data) => {\n          for (let i = 0; i < typeFunctions.length; i++) {\n            if (typeFunctions[i](data)) {\n              return;\n            }\n          }\n          return defineTypeError(\"Invalid type\", { data });\n        };\n      }\n      const typeAdapter = (_s, data) => combinedTypeValidator(data);\n      validators.push({\n        fn: getNamedFunction(typeMethodName, typeAdapter),\n        defineError: defineTypeError\n      });\n      activeNames.push(typeMethodName);\n    }\n    const { type, $id, $ref, $validate, required, ...otherKeys } = schema;\n    const keyOrder = required ? [...Object.keys(otherKeys), \"required\"] : Object.keys(otherKeys);\n    for (const key of keyOrder) {\n      const keywordFn = this.getKeyword(key);\n      if (keywordFn) {\n        const defineError = getDefinedErrorFunctionForKey(\n          key,\n          schema[key],\n          this.failFast\n        );\n        const fnName = keywordFn.name || key;\n        validators.push({\n          fn: keywordFn,\n          defineError\n        });\n        activeNames.push(fnName);\n      }\n    }\n    const literalKeywords = [\"enum\", \"const\", \"default\", \"examples\"];\n    for (const key of keyOrder) {\n      if (literalKeywords.includes(key)) {\n        continue;\n      }\n      if (isObject(schema[key])) {\n        if (key === \"properties\") {\n          for (const subKey of Object.keys(schema[key])) {\n            compiledSchema[key][subKey] = this.compileSchema(\n              schema[key][subKey]\n            );\n          }\n          continue;\n        }\n        compiledSchema[key] = this.compileSchema(schema[key]);\n        continue;\n      }\n      if (Array.isArray(schema[key])) {\n        for (let i = 0; i < schema[key].length; i++) {\n          if (this.isSchemaLike(schema[key][i])) {\n            compiledSchema[key][i] = this.compileSchema(schema[key][i]);\n          }\n        }\n        continue;\n      }\n    }\n    if (validators.length === 0) {\n      return compiledSchema;\n    }\n    if (validators.length === 1) {\n      const v = validators[0];\n      compiledSchema.$validate = getNamedFunction(\n        activeNames[0],\n        (data) => v.fn(compiledSchema, data, v.defineError, this)\n      );\n    } else {\n      const compositeName = \"Validate_\" + activeNames.join(\"_AND_\");\n      const masterValidator = (data) => {\n        for (let i = 0; i < validators.length; i++) {\n          const v = validators[i];\n          const error = v.fn(compiledSchema, data, v.defineError, this);\n          if (error) {\n            return error;\n          }\n        }\n        return;\n      };\n      compiledSchema.$validate = getNamedFunction(\n        compositeName,\n        masterValidator\n      );\n    }\n    return compiledSchema;\n  }\n  isSchemaLike(subSchema) {\n    if (isObject(subSchema)) {\n      if (\"type\" in subSchema) {\n        return true;\n      }\n      for (let subKey in subSchema) {\n        if (subKey in this.keywords) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  linkReferences(root) {\n    const stack = [root];\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!node || typeof node !== \"object\")\n        continue;\n      if (typeof node.$ref === \"string\" && typeof node.$validate === \"function\" && node.$validate.name === \"Validate_Reference\") {\n        const refPath = node.$ref;\n        let target = this.getSchemaRef(refPath);\n        if (typeof target === \"undefined\") {\n          target = this.getSchemaById(refPath);\n        }\n        if (typeof target === \"boolean\") {\n          if (target === true) {\n            node.$validate = getNamedFunction(\"Validate_Ref_True\", () => {\n            });\n          } else {\n            const defineError = getDefinedErrorFunctionForKey(\n              \"$ref\",\n              node,\n              this.failFast\n            );\n            node.$validate = getNamedFunction(\n              \"Validate_Ref_False\",\n              (_data) => defineError(\"Value is not valid\")\n            );\n          }\n          continue;\n        }\n        if (target && typeof target.$validate === \"function\") {\n          node.$validate = target.$validate;\n        }\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (!value)\n          continue;\n        if (Array.isArray(value)) {\n          for (let i = 0; i < value.length; i++) {\n            const v = value[i];\n            if (v && typeof v === \"object\") {\n              stack.push(v);\n            }\n          }\n        } else if (typeof value === \"object\") {\n          stack.push(value);\n        }\n      }\n    }\n  }\n};\nexport {\n  SchemaShield,\n  ValidationError,\n  deepClone\n};\n"],
  "mappings": "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",
  "names": []
}
