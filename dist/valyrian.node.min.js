!function(){"use strict";void 0!==typeof global&&(global.VNodeFactory=function(e){var n=require("fs"),t=require("uncss"),r=function(e,n){return function(t){if(t)return n(t);e()}};function s(){var e="";return function(t){if(!t)return e;e+=n.readFileSync(t,"utf8")}}e.inline={css:s(),js:s(),uncss:function(n,r){return void 0===r&&(r={}),r.raw=e.inline.css(),Promise.all(n).then(function(e){return new Promise(function(n,s){t(e,r,function(e,t){e&&s(e),n(t)})})})}},e.sw={generate:function(e,t){void 0===t&&(t={});var s=Object.assign({version:"v1::",name:"Valyrian.js",urls:["/"],debug:!1},t),o="let Log = console.log;\n\nlet config = {\n    version: 'v1::',\n    name: 'Valyrian.js',\n    urls: ['/']\n};\n\n// Function to add the network response to the cache\nlet fetchedFromNetwork = event => response => {\n    Log('WORKER: fetch response from network.', event.request.url);\n    if (!response || response.status !== 200 || response.type !== 'basic') {\n        return;\n    }\n\n    let cacheCopy = response.clone();\n    caches\n      .open(config.version + config.name)\n      .then(cache => cache.put(event.request, cacheCopy))\n      .then(() => Log('WORKER: fetch response stored in cache.', event.request.url));\n    return response;\n};\n\n// If the network or the cache response fail, response with Service Unavailable\nlet unableToResolve = () => {\n    Log('WORKER: fetch request failed in both cache and network.');\n    return new Response('<h1>Service Unavailable</h1>', {\n        status: 503,\n        statusText: 'Service Unavailable',\n        headers: new Headers({\n            'Content-Type': 'text/html'\n        })\n    });\n};\n\n// Fetch listener\nself.addEventListener(\"fetch\", event => {\n    Log('WORKER: fetch event in progress.', event.request.url);\n\n    let url = new URL(event.request.url);\n\n    // We only handle Get requests all others let them pass\n    if (event.request.method !== 'GET') {\n        return;\n    }\n\n    // TODO: Make a callback available here to filter if this request must be catched or let it pass directly\n    // This callback must return true or false\n\n    Log('WORKER: fetchevent for ' + url);\n\n    event.respondWith(\n        caches.match(event.request).then(cached => {\n            Log('WORKER: fetch event', cached ? '(cached)' : '(network)', event.request.url);\n\n            let network = fetch(event.request)\n                .then(fetchedFromNetwork(event), unableToResolve)\n                .catch(error => {\n                    console.log(error);\n                    return caches.match('/');\n                });\n\n            return network || cached;\n        })\n    );\n});\n\nself.addEventListener(\"install\", event => {\n    event.waitUntil(\n        // We can't use cache.add() here, since we want OFFLINE_URL to be the cache key, but\n        // the actual URL we end up requesting might include a cache-busting parameter.\n        caches.open(config.version + config.name)\n            .then(cache => cache.addAll(config.urls))\n            .catch(error => console.error('WORKER: Failed to cache', error))\n    );\n});\n\nself.addEventListener(\"activate\", event => {\n    event.waitUntil(\n        caches.keys()\n            .then(keys => Promise.all(\n                keys.filter(key => !key.startsWith(config.version)) // Filter by keys that don't start with the latest version prefix.\n                    .map(key => caches.delete(key)) // Return a promise that's fulfilled when each outdated cache is deleted.\n            ))\n            .then(() => self.clients.claim())\n    );\n});".replace("v1::","v"+s.version+"::").replace("Valyrian.js",s.name).replace("['/']",'["'+s.urls.join('","')+'"]');return s.debug||(o=o.replace("console.log","() => {}")),new Promise(function(t,s){n.writeFile(e,o,"utf8",r(t,s))})}},e.icons={options:{iconsPath:null,linksViewPath:null,path:"",appName:null,appDescription:null,developerName:null,developerURL:null,dir:"auto",lang:"en-US",background:"#fff",theme_color:"#fff",display:"standalone",orientation:"any",start_url:"/",version:"1.0",logging:!1,icons:{android:!0,appleIcon:!0,appleStartup:!0,coast:!1,favicons:!0,firefox:!1,windows:!0,yandex:!1}},generate:function(t,s,o){void 0===s&&(s={}),void 0===o&&(o=function(){});var a=require("favicons"),i=require("html2hs"),c=Object.assign({},e.icons.options,s);return c.iconsPath&&(c.iconsPath=c.iconsPath.replace(/\/$/gi,"")+"/"),c.iconsPath&&(c.linksViewPath=c.linksViewPath.replace(/\/$/gi,"")+"/"),new Promise(function(e,s){a(t,c,function(t,o){if(t)return console.log(t.status),console.log(t.name),console.log(t.message),s(t);var a=[];if(c.iconsPath){var l=function(e){a.push(new Promise(function(t,s){n.writeFile(c.iconsPath+o.images[e].name,o.images[e].contents,r(t,s))}))};for(var u in o.images)l(u);for(var h in o.files)a.push(new Promise(function(e,t){n.writeFile(c.iconsPath+o.files[h].name,o.files[h].contents,r(e,t))}))}if(c.linksViewPath){var f="export default { \n    view(){ \n        return [";for(var v in o.html)f+="\n            "+i(o.html[v])+",";f=f.replace(/,$/gi,"").replace(/h\("/gi,'v("')+"\n        ];\n    }\n};",a.push(new Promise(function(e,t){n.writeFile(c.linksViewPath+"/links.js",f,r(e,t))}))}Promise.all(a).then(function(){e(o)}).catch(s)})})}}})}();
