var swTpl="let Log = console.log;\n\nlet config = {\n    version: 'v1::',\n    name: 'Valyrian.js',\n    urls: ['/']\n};\n\n// Function to add the network response to the cache\nlet fetchedFromNetwork = event => response => {\n    Log('WORKER: fetch response from network.', event.request.url);\n    if (!response || response.status !== 200 || response.type !== 'basic') {\n        return;\n    }\n\n    let cacheCopy = response.clone();\n    caches\n        .open(config.version + config.name)\n        .then(cache => cache.put(event.request, cacheCopy))\n        .then(() => Log('WORKER: fetch response stored in cache.', event.request.url));\n    return response;\n};\n\n// If the network or the cache response fail, response with Service Unavailable\nlet unableToResolve = () => {\n    Log('WORKER: fetch request failed in both cache and network.');\n    return new Response('<h1>Service Unavailable</h1>', {\n        status: 503,\n        statusText: 'Service Unavailable',\n        headers: new Headers({\n            'Content-Type': 'text/html'\n        })\n    });\n};\n\n// Fetch listener\nself.addEventListener(\"fetch\", event => {\n    Log('WORKER: fetch event in progress.', event.request.url);\n\n    let url = new URL(event.request.url);\n\n    // We only handle Get requests all others let them pass\n    if (event.request.method !== 'GET') {\n        return;\n    }\n\n    // TODO: Make a callback available here to filter if this request must be catched or let it pass directly\n    // This callback must return true or false\n\n    Log('WORKER: fetchevent for ' + url);\n\n    event.respondWith(\n        caches.match(event.request).then(cached => {\n            Log('WORKER: fetch event', cached ? '(cached)' : '(network)', event.request.url);\n\n            let network = fetch(event.request)\n                .then(fetchedFromNetwork(event), unableToResolve)\n                .catch(error => {\n                    console.log(error);\n                    return caches.match('/');\n                });\n\n            return network || cached;\n        })\n    );\n});\n\nself.addEventListener(\"install\", event => {\n    event.waitUntil(\n        // We can't use cache.add() here, since we want OFFLINE_URL to be the cache key, but\n        // the actual URL we end up requesting might include a cache-busting parameter.\n        caches.open(config.version + config.name)\n            .then(cache => cache.addAll(config.urls))\n            .catch(error => console.error('WORKER: Failed to cache', error))\n    );\n});\n\nself.addEventListener(\"activate\", event => {\n    event.waitUntil(\n        caches.keys()\n            .then(keys => Promise.all(\n                keys.filter(key => !key.startsWith(config.version)) // Filter by keys that don't start with the latest version prefix.\n                    .map(key => caches.delete(key)) // Return a promise that's fulfilled when each outdated cache is deleted.\n            ))\n            .then(() => self.clients.claim())\n    );\n});\n",VNodeHelpersFactory=function(e){var n,t=require("fs"),r=require("uncss"),s=function(e,n){return function(t){if(t)return n(t);e()}};e.inline=function(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];var s=n.map(function(n){var r,s=n.split(".").pop();return e.inline[s]||(e.inline[s]=(r="",function(n){return n?/^https?:\/\//gi.test(n)?e.request.get(n,{},{headers:{Accept:"text/plain","Content-Type":"text/plain"}}).then(function(e){r+=e}):new Promise(function(e,s){t.readFile(n,"utf8",function(n,t){if(n)return s(n);e(r+=t)})}):r})),e.inline[s](n)});return Promise.all(s)},e.inline.uncss=(n="",function(t,s){return void 0===s&&(s={}),s.raw=e.inline.css(),t?Promise.all(t).then(function(e){return e.forEach(function(n,t){e[t]=n.replace(/<script [^>]*><\/script>/gi,"")}),new Promise(function(t,i){r(e,s,function(e,r){e&&i(e),n=r,t(r)})})}):n}),e.sw=function(e,n){void 0===n&&(n={});var r=Object.assign({version:"v1::",name:"Valyrian.js",urls:["/"],debug:!1},n),i=swTpl.replace("v1::","v"+r.version+"::").replace("Valyrian.js",r.name).replace("['/']",'["'+r.urls.join('","')+'"]');return r.debug||(i=i.replace("console.log","() => {}")),new Promise(function(n,r){t.writeFile(e,i,"utf8",s(n,r))})},e.icons=function(n,r){void 0===r&&(r={});var i=require("favicons"),o=require("html2hs"),a=Object.assign({},e.icons.options,r);return a.iconsPath&&(a.iconsPath=a.iconsPath.replace(/\/$/gi,"")+"/"),a.iconsPath&&(a.linksViewPath=a.linksViewPath.replace(/\/$/gi,"")+"/"),new Promise(function(e,r){i(n,a,function(n,i){if(n)return process.stdout.write(n.status+"\n"),process.stdout.write(n.name+"\n"),process.stdout.write(n.message+"\n"),r(n);var c=[];if(a.iconsPath){var l=function(e){c.push(new Promise(function(n,r){t.writeFile(a.iconsPath+i.images[e].name,i.images[e].contents,s(n,r))}))};for(var u in i.images)l(u);for(var h in i.files)c.push(new Promise(function(e,n){t.writeFile(a.iconsPath+i.files[h].name,i.files[h].contents,s(e,n))}))}if(a.linksViewPath){var f="export default { \n    view(){ \n        return [";for(var p in i.html)f+="\n            "+o(i.html[p])+",";f=f.replace(/,$/gi,"").replace(/h\("/gi,'v("')+"\n        ];\n    }\n};",c.push(new Promise(function(e,n){t.writeFile(a.linksViewPath+"/links.js",f,s(e,n))}))}Promise.all(c).then(function(){e(i)}).catch(r)})})},e.icons.options={iconsPath:null,linksViewPath:null,path:"",appName:null,appDescription:null,developerName:null,developerURL:null,dir:"auto",lang:"en-US",background:"#fff",theme_color:"#fff",display:"standalone",orientation:"any",start_url:"/",version:"1.0",logging:!1,icons:{android:!0,appleIcon:!0,appleStartup:!0,coast:!1,favicons:!0,firefox:!1,windows:!0,yandex:!1}}};module.exports=VNodeHelpersFactory;
