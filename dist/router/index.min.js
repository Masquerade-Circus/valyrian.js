(()=>{"use strict";var e=Object.defineProperty,t=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,n=Object.prototype.hasOwnProperty,o={};((t,r)=>{for(var n in r)e(t,n,{get:r[n],enumerable:!0})})(o,{Router:()=>w,RouterError:()=>p,afterRoute:()=>R,beforeRoute:()=>g,mountRouter:()=>C,redirect:()=>y});var s,i=(s=o,((o,s,i,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let u of r(s))n.call(o,u)||u===i||e(o,u,{get:()=>s[u],enumerable:!(a=t(s,u))||a.enumerable});return o})(e({},"__esModule",{value:!0}),s)),a=require("valyrian.js"),u=require("valyrian.js/utils");function l(e){let t=e.replace(/\/$/,"");return""===t&&(t="/"),t}function c(e){return Boolean(e)&&(0,u.isString)(e.name)&&e.name.includes("Error")}function h(e,t){const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(const n of r)if(String(e[n])!==String(t[n]))return!1;return!0}function f(e,t){return!t||(e.path!==t.path||!h(e.query,t.query)||!h(e.params,t.params))}var d,m=class{root={segment:"",children:new Map,isDynamic:!1};addRoute(e,t){const r="/"===e?[e]:e.split("/").filter(Boolean);let n=this.root;for(const e of r){const t=e.startsWith(":"),r=t?":":e;n.children.has(r)||n.children.set(r,{segment:e,children:new Map,isDynamic:t,paramKey:t?e.slice(1):void 0}),n=n.children.get(r)}n.middlewares=t}findRoute(e){const t=l(e),r="/"===t?[t]:t.split("/").filter(Boolean);let n=this.root;const o={},s=[],i=r.length;for(let e=0;e<i&&n;e++){const t=r[e];let i=!1;for(const[e,r]of n.children){if(e===t){n=r,i=!0;break}if(".*"!==t&&":"===e){n=r,o[r.paramKey]=t,i=!0;break}".*"!==e||i||s.push(...r.middlewares||[])}if(!i)return n.children.has(".*")?{middlewares:s,params:o}:null}const a=[...s,...n.middlewares||[]];return 0===a.length?null:{middlewares:a,params:o}}},p=class extends Error{status=500},w=class e{routeTree=new m;container=null;query={};options={};url="";path="";params={};matches=[];pathPrefix="";errorHandlers=new Map;beforeRouteCallbacks=[];afterRouteCallbacks=[];currentRoute=null;constructor(e=""){this.pathPrefix=e}beforeRoute(e){return this.beforeRouteCallbacks.push(e),()=>{this.beforeRouteCallbacks=this.beforeRouteCallbacks.filter(t=>t!==e)}}afterRoute(e){return this.afterRouteCallbacks.push(e),()=>{this.afterRouteCallbacks=this.afterRouteCallbacks.filter(t=>t!==e)}}add(...t){const r=(n=t,Array.isArray(n)?n.flat(1/0):[n]);var n;const o=l(`${this.pathPrefix}${(0,u.isString)(r[0])?r.shift():"/.*"}`);if(1===r.length&&r[0]instanceof e){const e=r[0];for(const t of e.routes()){const r=`${o}${t}`;this.routeTree.addRoute(r,e.routeTree.findRoute(t).middlewares||[])}}else{if(r.some(t=>t instanceof e))throw new p("You cannot add middlewares when adding a subrouter.");if(r.some(e=>!(0,u.isFunction)(e)))throw new p("All middlewares must be functions.");this.routeTree.addRoute(o,r)}return this}catch(...e){const t=e[0],r=(0,u.isNumber)(t)||(0,u.isString)(t)||c(t)?e.shift():"generic";if(!(0,u.isNumber)(r)&&!(0,u.isString)(r)&&!c(r))throw new p("The condition must be a number, string or an instance of Error.");if(e.some(e=>!(0,u.isFunction)(e)))throw new p("All middlewares must be functions.");let n=this.errorHandlers.get(r);return n||(n=[],this.errorHandlers.set(r,n)),n.push(...e),this}routes(){return this.getAllRoutes(this.routeTree.root,"")}async go(e,t){if(!e)return this.handleError(new p("The URL is empty."),t);if(/%[^0-9A-Fa-f]{2}/.test(e))return this.handleError(new p(`The URL ${e} is malformed.`));const r=l(`${this.pathPrefix}${e}`),n=r.split("?",2),o=function(e){const t=e?e.split("&"):[],r={};for(const e of t){const[t,n]=e.split("=",2);r[t]=!1===isNaN(Number(n))?Number(n):"true"===n||"false"!==n&&n}return r}(n[1]),s=n[0].replace(/(.+)\/$/,"$1").split("#")[0];let i=this.routeTree.findRoute(s);if(!i||!i.middlewares){const e=s.split("/");for(;e.length>0;){e.pop();const t=this.routeTree.findRoute(e.join("/")+"/.*");if(t){i=t;break}}if(!i||!i.middlewares){const e=new p(`The URL ${r} was not found in the router's registered paths.`);return e.status=404,this.handleError(e,t)}}const{middlewares:u,params:c}=i,h={path:l(e),query:o,params:c};if(f(h,this.currentRoute))for(const e of this.beforeRouteCallbacks){if(!1===await e(h,this.currentRoute))return}this.url=r,this.query=o,this.path=e,this.params=c;let d,m=await this.searchComponent(u,t);if(!1!==m){if(!m)return this.handleError(new p(`The URL ${r} did not return a valid component.`),t);if((0,a.isComponent)(t)||(0,a.isVnodeComponent)(t)){const e=(0,a.isVnodeComponent)(m)?m:(0,a.v)(m,{});(0,a.isVnodeComponent)(t)?(t.children.push(e),m=t):m=(0,a.v)(t,{},e)}if(a.isNodeJs||window.location.pathname+window.location.search===r||window.history.pushState(null,"",r),this.container&&(d=await(0,a.mount)(this.container,m)),f(h,this.currentRoute)){const e=this.currentRoute;this.currentRoute=h;for(const t of this.afterRouteCallbacks)await t(h,e)}return d}}getOnClickHandler(e){return t=>{0!==t.button||t.ctrlKey||t.metaKey||t.shiftKey||t.altKey||t.defaultPrevented||((0,u.isString)(e)&&e.length>0&&this.go(e),t.preventDefault())}}getAllRoutes(e,t){const r=[];for(const[n,o]of e.children){const e=`${t}/${o.isDynamic?`:${o.paramKey}`:n}`.replace(/\/$/,"");o.middlewares&&r.push(e),r.push(...this.getAllRoutes(o,e))}return r}createRequest(){return{params:this.params,query:this.query,url:this.url,path:this.path,matches:this.matches,redirect:e=>this.go(e)}}getErrorConditionMiddlewares(e){for(const[t,r]of this.errorHandlers)if(!(0,u.isNumber)(t)&&!(0,u.isString)(t)&&e instanceof t&&e.name===t.name)return r;for(const[t,r]of this.errorHandlers)if((0,u.isNumber)(t)&&(e.status===t||e.code===t))return r;for(const[t,r]of this.errorHandlers)if((0,u.isString)(t)&&(e.name===t||e.message.includes(t)))return r;return this.errorHandlers.get("generic")||!1}async handleError(e,t){const r=this.createRequest();let n=null;const o=this.getErrorConditionMiddlewares(e);if(!1===o)throw e;let s;try{for(const t of o){if(s=await t(r,e),void 0!==s&&((0,a.isComponent)(s)||(0,a.isVnodeComponent)(s))){n=s;break}if(!1===s)return}}catch(r){const n=r instanceof Error?r:new p(String(r));if(n===e)throw new p("Too many error causes. Possible circular error handling.");n.cause||(n.cause=e);let o=0;const s=new Set;let i=n;for(;i instanceof Error&&i.cause;){if(s.has(i))throw new p("Too many error causes. Possible circular error handling.");if(s.add(i),o++,o>20)throw new p("Too many error causes. Possible circular error handling.");i=i.cause}return this.handleError(n,t)}if(n){if((0,a.isComponent)(t)||(0,a.isVnodeComponent)(t)){const e=(0,a.isVnodeComponent)(n)?n:(0,a.v)(n,{});(0,a.isVnodeComponent)(t)?(t.children.push(e),n=t):n=(0,a.v)(t,{},e)}if(a.isNodeJs||window.location.pathname+window.location.search===this.url||window.history.pushState(null,"",this.url),this.container)return(0,a.mount)(this.container,n)}throw e}async searchComponent(e,t){const r=this.createRequest();let n;for(const o of e){try{n=await o(r)}catch(e){return this.handleError(e,t)}if(void 0!==n&&((0,a.isComponent)(n)||(0,a.isVnodeComponent)(n)))return n;if(!1===n)return!1}return n}},b=null;function g(e){if(!b)throw new p("Router is not mounted. Call mountRouter(...) before registering route callbacks.");const t=b.beforeRoute(e);try{(0,a.onRemove)(()=>t())}catch{}return t}function R(e){if(!b)throw new p("Router is not mounted. Call mountRouter(...) before registering route callbacks.");const t=b.afterRoute(e);try{(0,a.onRemove)(()=>t())}catch{}return t}async function y(e,t,r=!1){if(d)return d(e,t,r);console.warn("Redirect function is not initialized. Please mount the router first.")}function C(e,t){if(t.container=e,d=t.go.bind(t),b=t,!a.isNodeJs){let e=function(){const e=(r=document.location.pathname,n=t.pathPrefix,l(r.replace(new RegExp(`^${n}`),"")));var r,n;t.go(e)};window.addEventListener("popstate",e,!1),e()}(0,a.directive)("route",(e,r)=>{(0,a.setAttribute)("href",e,r),(0,a.setAttribute)("onclick",t.getOnClickHandler(e),r)})}"undefined"!=typeof module?module.exports=i:self.ValyrianRouter=i})();//# sourceMappingURL=index.min.js.map