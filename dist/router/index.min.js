(()=>{"use strict";var e=Object.defineProperty,t=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,n=Object.prototype.hasOwnProperty,o={};((t,r)=>{for(var n in r)e(t,n,{get:r[n],enumerable:!0})})(o,{Router:()=>g,RouterError:()=>p,afterRoute:()=>R,beforeRoute:()=>w,mountRouter:()=>y,redirect:()=>C});var i,s=(i=o,((o,i,s,a)=>{if(i&&"object"==typeof i||"function"==typeof i)for(let l of r(i))n.call(o,l)||l===s||e(o,l,{get:()=>i[l],enumerable:!(a=t(i,l))||a.enumerable});return o})(e({},"__esModule",{value:!0}),i)),a=require("valyrian.js"),l=require("valyrian.js/utils");function c(e){let t=e.replace(/\/$/,"");return""===t&&(t="/"),t}function u(e){return Boolean(e)&&(0,l.isString)(e.name)&&e.name.includes("Error")}function h(){return{before:new Set,after:new Set}}function d(e,t){const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(const n of r)if(String(e[n])!==String(t[n]))return!1;return!0}var f,m=class{root={segment:"",children:new Map,isDynamic:!1};addRoute(e,t){const r="/"===e?[e]:e.split("/").filter(Boolean);let n=this.root;for(const e of r){const t=e.startsWith(":"),r=t?":":e;n.children.has(r)||n.children.set(r,{segment:e,children:new Map,isDynamic:t,paramKey:t?e.slice(1):void 0}),n=n.children.get(r)}n.middlewares=t}findRoute(e){const t=c(e),r="/"===t?[t]:t.split("/").filter(Boolean);let n=this.root;const o={},i=[],s=r.length;for(let e=0;e<s&&n;e++){const t=r[e];let s=!1;for(const[e,r]of n.children){if(e===t){n=r,s=!0;break}if(".*"!==t&&":"===e){n=r,o[r.paramKey]=t,s=!0;break}".*"!==e||s||i.push(...r.middlewares||[])}if(!s)return n.children.has(".*")?{middlewares:i,params:o}:null}const a=[...i,...n.middlewares||[]];return 0===a.length?null:{middlewares:a,params:o}}},p=class extends Error{status=500},g=class e{routeTree=new m;container=null;query={};options={};url="";path="";params={};matches=[];pathPrefix="";errorHandlers=new Map;activeRouteCallbacks=h();pendingRouteCallbacks=null;callbackRegistrationTarget="active";currentRoute=null;constructor(e=""){this.pathPrefix=e}getRegistrationCallbacks(){return"pending"===this.callbackRegistrationTarget&&this.pendingRouteCallbacks?this.pendingRouteCallbacks:this.activeRouteCallbacks}beginPendingRouteCallbacksCollection(){this.pendingRouteCallbacks=h(),this.callbackRegistrationTarget="pending"}commitPendingRouteCallbacksCollection(){this.activeRouteCallbacks=this.pendingRouteCallbacks||h(),this.pendingRouteCallbacks=null,this.callbackRegistrationTarget="active"}rollbackPendingRouteCallbacksCollection(){this.pendingRouteCallbacks=null,this.callbackRegistrationTarget="active"}beforeRoute(e){return this.getRegistrationCallbacks().before.add(e),()=>{this.activeRouteCallbacks.before.delete(e),this.pendingRouteCallbacks?.before.delete(e)}}afterRoute(e){return this.getRegistrationCallbacks().after.add(e),()=>{this.activeRouteCallbacks.after.delete(e),this.pendingRouteCallbacks?.after.delete(e)}}add(...t){const r=(n=t,Array.isArray(n)?n.flat(1/0):[n]);var n;const o=c(`${this.pathPrefix}${(0,l.isString)(r[0])?r.shift():"/.*"}`);if(1===r.length&&r[0]instanceof e){const e=r[0];for(const t of e.routes()){const r=`${o}${t}`;this.routeTree.addRoute(r,e.routeTree.findRoute(t).middlewares||[])}}else{if(r.some(t=>t instanceof e))throw new p("You cannot add middlewares when adding a subrouter.");if(r.some(e=>!(0,l.isFunction)(e)))throw new p("All middlewares must be functions.");this.routeTree.addRoute(o,r)}return this}catch(...e){const t=e[0],r=(0,l.isNumber)(t)||(0,l.isString)(t)||u(t)?e.shift():"generic";if(!(0,l.isNumber)(r)&&!(0,l.isString)(r)&&!u(r))throw new p("The condition must be a number, string or an instance of Error.");if(e.some(e=>!(0,l.isFunction)(e)))throw new p("All middlewares must be functions.");let n=this.errorHandlers.get(r);return n||(n=[],this.errorHandlers.set(r,n)),n.push(...e),this}routes(){return this.getAllRoutes(this.routeTree.root,"")}async go(e,t){if(!e)return this.handleError(new p("The URL is empty."),t);if(/%[^0-9A-Fa-f]{2}/.test(e))return this.handleError(new p(`The URL ${e} is malformed.`));const r=c(`${this.pathPrefix}${e}`),n=r.split("?",2),o=function(e){const t=e?e.split("&"):[],r={};for(const e of t){const[t,n]=e.split("=",2);r[t]=!1===isNaN(Number(n))?Number(n):"true"===n||"false"!==n&&n}return r}(n[1]),i=n[0].replace(/(.+)\/$/,"$1").split("#")[0];let s=this.routeTree.findRoute(i);if(!s||!s.middlewares){const e=i.split("/");for(;e.length>0;){e.pop();const t=this.routeTree.findRoute(e.join("/")+"/.*");if(t){s=t;break}}if(!s||!s.middlewares){const e=new p(`The URL ${r} was not found in the router's registered paths.`);return e.status=404,this.handleError(e,t)}}const{middlewares:l,params:u}=s,h={path:c(e),query:o,params:u},f=function(e,t){return!t||e.path!==t.path||!d(e.query,t.query)||!d(e.params,t.params)}(h,this.currentRoute);if(f){for(const e of this.activeRouteCallbacks.before){if(!1===await e(h,this.currentRoute))return}this.beginPendingRouteCallbacksCollection()}else this.callbackRegistrationTarget="active";let m=!1;try{this.url=r,this.query=o,this.path=e,this.params=u;let n,i=await this.searchComponent(l,t);if(!1===i)return;if(!i)return this.handleError(new p(`The URL ${r} did not return a valid component.`),t);if((0,a.isComponent)(t)||(0,a.isVnodeComponent)(t)){const e=(0,a.isVnodeComponent)(i)?i:(0,a.v)(i,{});(0,a.isVnodeComponent)(t)?(t.children.push(e),i=t):i=(0,a.v)(t,{},e)}if(a.isNodeJs||window.location.pathname+window.location.search===r||window.history.pushState(null,"",r),this.container&&(n=await(0,a.mount)(this.container,i)),f){const e=this.currentRoute,t=this.activeRouteCallbacks.after;this.currentRoute=h,this.commitPendingRouteCallbacksCollection(),m=!0;for(const r of t)await r(h,e)}return n}finally{f&&!m&&this.rollbackPendingRouteCallbacksCollection()}}getOnClickHandler(e){return t=>{0!==t.button||t.ctrlKey||t.metaKey||t.shiftKey||t.altKey||t.defaultPrevented||((0,l.isString)(e)&&e.length>0&&this.go(e),t.preventDefault())}}getAllRoutes(e,t){const r=[];for(const[n,o]of e.children){const e=`${t}/${o.isDynamic?`:${o.paramKey}`:n}`.replace(/\/$/,"");o.middlewares&&r.push(e),r.push(...this.getAllRoutes(o,e))}return r}createRequest(){return{params:this.params,query:this.query,url:this.url,path:this.path,matches:this.matches,redirect:e=>this.go(e)}}getErrorConditionMiddlewares(e){for(const[t,r]of this.errorHandlers)if(!(0,l.isNumber)(t)&&!(0,l.isString)(t)&&e instanceof t&&e.name===t.name)return r;for(const[t,r]of this.errorHandlers)if((0,l.isNumber)(t)&&(e.status===t||e.code===t))return r;for(const[t,r]of this.errorHandlers)if((0,l.isString)(t)&&(e.name===t||e.message.includes(t)))return r;return this.errorHandlers.get("generic")||!1}async handleError(e,t){const r=this.createRequest();let n=null;const o=this.getErrorConditionMiddlewares(e);if(!1===o)throw e;let i;try{for(const t of o){if(i=await t(r,e),void 0!==i&&((0,a.isComponent)(i)||(0,a.isVnodeComponent)(i))){n=i;break}if(!1===i)return}}catch(r){const n=r instanceof Error?r:new p(String(r));if(n===e)throw new p("Too many error causes. Possible circular error handling.");n.cause||(n.cause=e);let o=0;const i=new Set;let s=n;for(;s instanceof Error&&s.cause;){if(i.has(s))throw new p("Too many error causes. Possible circular error handling.");if(i.add(s),o++,o>20)throw new p("Too many error causes. Possible circular error handling.");s=s.cause}return this.handleError(n,t)}if(n){if((0,a.isComponent)(t)||(0,a.isVnodeComponent)(t)){const e=(0,a.isVnodeComponent)(n)?n:(0,a.v)(n,{});(0,a.isVnodeComponent)(t)?(t.children.push(e),n=t):n=(0,a.v)(t,{},e)}if(a.isNodeJs||window.location.pathname+window.location.search===this.url||window.history.pushState(null,"",this.url),this.container)return(0,a.mount)(this.container,n)}throw e}async searchComponent(e,t){const r=this.createRequest();let n;for(const o of e){try{n=await o(r)}catch(e){return this.handleError(e,t)}if(void 0!==n&&((0,a.isComponent)(n)||(0,a.isVnodeComponent)(n)))return n;if(!1===n)return!1}return n}},b=null;function w(e){if(!b)throw new p("Router is not mounted. Call mountRouter(...) before registering route callbacks.");if(!a.current.vnode)throw new p("beforeRoute must be called inside a component context.");return b.beforeRoute(e)}function R(e){if(!b)throw new p("Router is not mounted. Call mountRouter(...) before registering route callbacks.");if(!a.current.vnode)throw new p("afterRoute must be called inside a component context.");return b.afterRoute(e)}async function C(e,t,r=!1){if(f)return f(e,t,r);console.warn("Redirect function is not initialized. Please mount the router first.")}function y(e,t){if(t.container=e,f=t.go.bind(t),b=t,!a.isNodeJs){let e=function(){const e=(r=document.location.pathname,n=t.pathPrefix,c(r.replace(new RegExp(`^${n}`),"")));var r,n;t.go(e)};window.addEventListener("popstate",e,!1),e()}(0,a.directive)("route",(e,r)=>{(0,a.setAttribute)("href",e,r),(0,a.setAttribute)("onclick",t.getOnClickHandler(e),r)})}"undefined"!=typeof module?module.exports=s:self.ValyrianRouter=s})();//# sourceMappingURL=index.min.js.map