(()=>{"use strict";var e=Object.defineProperty,t=Object.getOwnPropertyDescriptor,i=Object.getOwnPropertyNames,s=Object.prototype.hasOwnProperty,r={};((t,i)=>{for(var s in i)e(t,s,{get:i[s],enumerable:!0})})(r,{FluxStore:()=>h});var n,o=(n=r,((r,n,o,a)=>{if(n&&"object"==typeof n||"function"==typeof n)for(let c of i(n))s.call(r,c)||c===o||e(r,c,{get:()=>n[c],enumerable:!(a=t(n,c))||a.enumerable});return r})(e({},"__esModule",{value:!0}),n)),a=require("valyrian.js"),c=require("valyrian.js/utils"),h=class e{state;getters;init;rootStore;namespace;constructor({state:t={},mutations:i={},actions:s={},getters:r={},modules:n={},shouldFreeze:o=!0,namespace:a,rootStore:h}={}){const l="function"==typeof t?t():t;this.state=new Proxy(l||{},{get:(e,t)=>{if((this.rootStore||this).init.modules[t])return e[t];if(o){if(this.init.frozen)return(0,c.deepFreeze)(e[t]);const i=(0,c.deepCloneUnfreeze)(e);for(const e of Reflect.ownKeys(i))l[e]=i[e]}return e[t]},set:(e,t,i)=>{this.isUnfrozen();const s=e[t];return e[t]=i,this.namespace&&(t=`${this.namespace}.${t}`),(this.rootStore||this).trigger("set",t,i,s),!0},deleteProperty:(e,t)=>{this.isUnfrozen();const i=e[t];return Reflect.deleteProperty(e,t),this.namespace&&(t=`${this.namespace}.${t}`),(this.rootStore||this).trigger("delete",t,i),!0}}),this.rootStore=h||null,this.namespace=a||null,this.init={frozen:!0,plugins:[],modules:{},childModuleNamespaces:Object.keys(n||{}),listeners:{set:[],delete:[],beforecommit:[],commit:[],beforedispatch:[],dispatch:[],getter:[],addlistener:[],removelistener:[],plugin:[],registerModule:[],unregisterModule:[]},getters:r||{},mutations:i||{},actions:s||{}},this.getters=new Proxy(r||{},{get:(t,i)=>{try{const{store:t,key:s}=this.getStore(this,i);if(t instanceof e&&t.init.getters[s]){const e=t.init.getters[s](t.state,t.getters,this.state,this.getters);return this.namespace&&(i=`${this.namespace}.${i}`),(this.rootStore||this).trigger("getter",i,e),e}}catch(e){return}}}),n&&Object.keys(n).forEach(e=>{const t=this.namespace?`${this.namespace}.${e}`:e;(this.rootStore||this).registerModule(t,n[e])})}keyExists(e,t,i){if(!t[i])throw new Error(`The ${e} "${i}" does not exists.`)}isFunction(e,t){if("function"!=typeof t)throw new Error(`You need to provide a valid function as ${e}.`)}getStore(e,t){let i=t;if(i.indexOf(".")>-1){const t=i.split(".");i=t.pop();const s=t.join(".");this.keyExists("module",e.init.modules,s),e=e.init.modules[s]}return{store:e,key:i}}isUnfrozen(){if(this.init.frozen)throw new Error("You need to commit a mutation to change the state")}commit(e,...t){const{store:i,key:s}=this.getStore(this,e);this.keyExists("mutation",i.init.mutations,s),i.init.frozen=!1,this.trigger("beforecommit",e,...t),i.init.mutations[s](i.state,...t),this.trigger("commit",e,...t),i.init.frozen=!0,(0,a.debouncedUpdate)()}async dispatch(e,...t){const{store:i,key:s}=this.getStore(this,e);this.keyExists("action",i.init.actions,s),this.trigger("beforedispatch",e,...t);try{const r=await i.init.actions[s](i,...t);return this.trigger("dispatch",e,...t),r}finally{(0,a.debouncedUpdate)()}}trigger(e,...t){this.init.listeners[e].forEach(e=>e(this,...t))}on(e,t){return this.isFunction("listener",t),this.keyExists("event",this.init.listeners,e),-1===this.init.listeners[e].indexOf(t)&&(this.init.listeners[e].push(t),this.trigger("addlistener",e,t)),()=>this.off(e,t)}off(e,t){this.isFunction("listener",t),this.keyExists("event",this.init.listeners,e);const i=this.init.listeners[e].indexOf(t);i>-1&&(this.init.listeners[e].splice(i,1),this.trigger("removelistener",e,t))}use(e,...t){this.isFunction("plugin",e),-1===this.init.plugins.indexOf(e)&&(e(this,...t),this.init.plugins.push(e),this.trigger("plugin",e,...t))}registerModule(t,i){const s=this;if(s.init.modules[t])throw new Error(`A module with the namespace "${t}" is already registered.`);const r=new e({...i,rootStore:s,namespace:t});s.init.frozen=!1,s.init.modules[t]=r,s.state[t]=r.state,s.init.frozen=!0,s.trigger("registerModule",t,i,r),(0,a.debouncedUpdate)()}unregisterModule(e){const t=this,i=t.init.modules[e];i&&(i.init.childModuleNamespaces.forEach(i=>t.unregisterModule(`${e}.${i}`)),t.init.frozen=!1,Reflect.deleteProperty(t.init.modules,e),Reflect.deleteProperty(t.state,e),t.init.frozen=!0,t.trigger("unregisterModule",e,i),(0,a.debouncedUpdate)())}};"undefined"!=typeof module?module.exports=o:self.ValyrianFluxStore=o})();//# sourceMappingURL=index.min.js.map