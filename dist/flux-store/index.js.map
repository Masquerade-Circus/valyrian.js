{
  "version": 3,
  "sources": ["../../lib/flux-store/index.ts"],
  "sourcesContent": ["import { debouncedUpdate } from \"valyrian.js\";\nimport { deepCloneUnfreeze, deepFreeze } from \"valyrian.js/utils\";\n\ninterface StoreOptions {\n  state?: Record<string, any> | (() => Record<string, any>);\n  // eslint-disable-next-line no-unused-vars\n  mutations?: Record<string, (state: Record<string, any>, ...args: any[]) => void>;\n  // eslint-disable-next-line no-unused-vars, no-use-before-define\n  actions?: Record<string, (store: FluxStore, ...args: any[]) => any>;\n  getters?: Record<\n    string,\n    // eslint-disable-next-line no-unused-vars\n    (state: Record<string, any>, getters: Record<string, any>, globalState?: any, globalGetters?: any) => any\n  >;\n  modules?: Record<string, StoreOptions>;\n  shouldFreeze?: boolean;\n  namespace?: string;\n  // eslint-disable-next-line no-use-before-define\n  rootStore?: FluxStore;\n}\n\n// This is the store entity\nexport class FluxStore {\n  public state: Record<string, any>;\n  public getters: Record<string, any>;\n  private init: {\n    frozen: boolean;\n    plugins: Function[];\n    // eslint-disable-next-line no-use-before-define\n    modules: Record<string, FluxStore>;\n    childModuleNamespaces: string[];\n    listeners: Record<string, Function[]>;\n    getters: StoreOptions[\"getters\"];\n    mutations: StoreOptions[\"mutations\"];\n    actions: StoreOptions[\"actions\"];\n  };\n  // eslint-disable-next-line no-use-before-define\n  public rootStore: FluxStore | null;\n  public namespace: string | null;\n\n  // eslint-disable-next-line sonarjs/cognitive-complexity\n  constructor({\n    state = {},\n    mutations = {},\n    actions = {},\n    getters = {},\n    modules = {},\n    shouldFreeze = true,\n    namespace,\n    rootStore\n  }: StoreOptions = {}) {\n    // Initialize the localState for this store\n    const localState = typeof state === \"function\" ? state() : state;\n\n    // We create a proxy for the state\n    this.state = new Proxy(localState || {}, {\n      // Every time we try to access a property from the state we try to deep freeze the property\n      // to prevent direct modifications to the state\n      get: (state, prop: string) => {\n        if ((this.rootStore || this).init.modules[prop]) {\n          return state[prop];\n        }\n        if (shouldFreeze) {\n          // We are accessing a property from outside the store\n          if (this.init.frozen) {\n            return deepFreeze(state[prop]);\n          }\n\n          // We are accessing a property from inside the store\n          // So we need to unfreeze the state\n          const newState = deepCloneUnfreeze(state);\n          for (const key of Reflect.ownKeys(newState)) {\n            localState[key] = newState[key];\n          }\n        }\n        return state[prop];\n      },\n      // If the user tries to set directly it will throw an error, only if we have unfrozen the state via commit\n      // this will proceed to set the value\n      set: (state, prop: string, value: any) => {\n        this.isUnfrozen();\n        const old = state[prop];\n        state[prop] = value;\n        if (this.namespace) {\n          prop = `${this.namespace}.${prop}`;\n        }\n        (this.rootStore || this).trigger(\"set\", prop, value, old);\n        return true;\n      },\n      // If the user tries to delete directly it will throw an error, only if we have unfrozen the state via commit\n      // this will proceed to delete the property\n      deleteProperty: (state, prop: string) => {\n        this.isUnfrozen();\n        const old = state[prop];\n        Reflect.deleteProperty(state, prop);\n        if (this.namespace) {\n          prop = `${this.namespace}.${prop}`;\n        }\n        (this.rootStore || this).trigger(\"delete\", prop, old);\n        return true;\n      }\n    });\n\n    // If this is a store been attached to another store\n    // this will have the rootStore for future reference\n    this.rootStore = rootStore || null;\n\n    // If this is a store been attached to another store\n    // this will have the namespace attached\n    this.namespace = namespace || null;\n\n    // We initialize the store with the initial values\n    this.init = {\n      frozen: true,\n      plugins: [],\n      modules: {},\n      childModuleNamespaces: Object.keys(modules || {}),\n      listeners: {\n        set: [],\n        delete: [],\n        beforecommit: [],\n        commit: [],\n        beforedispatch: [],\n        dispatch: [],\n        getter: [],\n        addlistener: [],\n        removelistener: [],\n        plugin: [],\n        registerModule: [],\n        unregisterModule: []\n      },\n      getters: getters || {},\n      mutations: mutations || {},\n      actions: actions || {}\n    };\n\n    // We create a proxy for the getters\n    this.getters = new Proxy(getters || {}, {\n      // When we try to get a property of the getter we will call the original\n      // getter method passing the state as first argument and the other getters as second\n      // if we try to get a non existent getter it will fail silently as if\n      // we were trying to get an undefined property\n      get: (getters, getter: string) => {\n        try {\n          const { store, key } = this.getStore(this, getter);\n          if (store instanceof FluxStore && store.init.getters![key]) {\n            const value = store.init.getters![key](store.state, store.getters, this.state, this.getters);\n            if (this.namespace) {\n              getter = `${this.namespace}.${getter}`;\n            }\n            (this.rootStore || this).trigger(\"getter\", getter, value);\n            return value;\n          }\n        } catch (error) {\n          return;\n        }\n      }\n    });\n\n    // Finally we attach the initial modules\n    if (modules) {\n      Object.keys(modules).forEach((namespace) => {\n        const n = this.namespace ? `${this.namespace}.${namespace}` : namespace;\n        (this.rootStore || this).registerModule(n, modules[namespace]);\n      });\n    }\n  }\n\n  private keyExists(objectname: string, object: Record<string, any>, key: string) {\n    if (!object[key]) {\n      throw new Error(`The ${objectname} \"${key}\" does not exists.`);\n    }\n  }\n\n  private isFunction(type: string, callback: Function) {\n    if (typeof callback !== \"function\") {\n      throw new Error(`You need to provide a valid function as ${type}.`);\n    }\n  }\n\n  // Giving a dot based namespace this method will be used to find the module to be called\n  private getStore(store: FluxStore, namespace: string) {\n    let key = namespace;\n    if (key.indexOf(\".\") > -1) {\n      const parts = key.split(\".\");\n      key = parts.pop()!;\n      const moduleName = parts.join(\".\");\n      this.keyExists(\"module\", store.init.modules, moduleName);\n      store = store.init.modules[moduleName];\n    }\n    return {\n      store,\n      key\n    };\n  }\n\n  private isUnfrozen() {\n    if (this.init.frozen) {\n      throw new Error(\"You need to commit a mutation to change the state\");\n    }\n  }\n\n  // This method unfroze the state and process a mutation\n  public commit(mutation: string, ...args: any[]) {\n    const { store, key } = this.getStore(this, mutation);\n    this.keyExists(\"mutation\", store.init.mutations!, key);\n    store.init.frozen = false;\n    this.trigger(\"beforecommit\", mutation, ...args);\n    store.init.mutations![key](store.state, ...args);\n    this.trigger(\"commit\", mutation, ...args);\n    store.init.frozen = true;\n\n    // We call the debounced update to notify the changes\n    debouncedUpdate();\n  }\n\n  // This method will dispatch an action\n  public async dispatch(action: string, ...args: any[]): Promise<any> {\n    const { store, key } = this.getStore(this, action);\n    this.keyExists(\"action\", store.init.actions!, key);\n    this.trigger(\"beforedispatch\", action, ...args);\n    try {\n      const result = await store.init.actions![key](store, ...args);\n      this.trigger(\"dispatch\", action, ...args);\n      return result;\n    } finally {\n      debouncedUpdate();\n    }\n  }\n\n  // This method will trigger an event\n  public trigger(event: string, ...args: any[]) {\n    this.init.listeners[event].forEach((callback) => callback(this, ...args));\n  }\n\n  // This method will add a listener to the store\n  public on(event: string, listener: Function) {\n    this.isFunction(\"listener\", listener);\n    this.keyExists(\"event\", this.init.listeners, event);\n    if (this.init.listeners[event].indexOf(listener) === -1) {\n      this.init.listeners[event].push(listener);\n      this.trigger(\"addlistener\", event, listener);\n    }\n    return () => this.off(event, listener);\n  }\n\n  // Remove a listener from the store\n  public off(event: string, listener: Function) {\n    this.isFunction(\"listener\", listener);\n    this.keyExists(\"event\", this.init.listeners, event);\n    const index = this.init.listeners[event].indexOf(listener);\n    if (index > -1) {\n      this.init.listeners[event].splice(index, 1);\n      this.trigger(\"removelistener\", event, listener);\n    }\n  }\n\n  // This method will add a plugin to the store\n  public use(plugin: Function, ...options: any[]) {\n    this.isFunction(\"plugin\", plugin);\n    if (this.init.plugins.indexOf(plugin) === -1) {\n      plugin(this, ...options);\n      this.init.plugins.push(plugin);\n      this.trigger(\"plugin\", plugin, ...options);\n    }\n  }\n\n  // This method will register a module to the store\n  public registerModule(namespace: string, module: StoreOptions) {\n    const rootStore = this;\n    if (rootStore.init.modules[namespace]) {\n      throw new Error(`A module with the namespace \"${namespace}\" is already registered.`);\n    }\n    const newStore = new FluxStore({ ...module, rootStore, namespace });\n    rootStore.init.frozen = false;\n    rootStore.init.modules[namespace] = newStore;\n    rootStore.state[namespace] = newStore.state;\n    rootStore.init.frozen = true;\n    rootStore.trigger(\"registerModule\", namespace, module, newStore);\n\n    // We call the debounced update to notify the changes\n    debouncedUpdate();\n  }\n\n  // This method will unregister a module from the store\n  public unregisterModule(namespace: string) {\n    const rootStore = this;\n    const store = rootStore.init.modules[namespace];\n    if (store) {\n      store.init.childModuleNamespaces.forEach((n) => rootStore.unregisterModule(`${namespace}.${n}`));\n      rootStore.init.frozen = false;\n      Reflect.deleteProperty(rootStore.init.modules, namespace);\n      Reflect.deleteProperty(rootStore.state, namespace);\n      rootStore.init.frozen = true;\n      rootStore.trigger(\"unregisterModule\", namespace, store);\n\n      // We call the debounced update to notify the changes\n      debouncedUpdate();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["state", "getters", "namespace", "module"]
}
