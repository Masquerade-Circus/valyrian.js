{
  "version": 3,
  "sources": ["../../lib/pulses/index.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\nimport { updateVnode, VnodeWithDom, current, DomElement } from \"valyrian.js\";\nimport { deepCloneUnfreeze, deepFreeze, hasChanged } from \"valyrian.js/utils\";\n\ntype State = Record<string, any>;\n\nexport type PulseContext = {\n  $flush: () => Promise<void>;\n};\n\nexport type Pulse<StateType, TReturn = unknown> = (state: StateType, ...args: any[]) => TReturn | Promise<TReturn>;\n\ntype ProxyState<StateType> = StateType & { [key: string]: any };\n\nconst effectStack: Function[] = [];\n\ntype StorePulses<PulsesType> = {\n  [K in keyof PulsesType]: PulsesType[K] extends (state: any, ...args: infer Args) => infer R\n    ? (...args: Args) => R\n    : never;\n};\n\nfunction registerDomSubscription(subscribers: Set<Function>, domWithVnodesToUpdate: WeakSet<DomElement>): void {\n  const currentVnode = current.vnode as VnodeWithDom;\n  if (!currentVnode || domWithVnodesToUpdate.has(currentVnode.dom)) {\n    return;\n  }\n\n  let hasParent = false;\n  let parent = currentVnode.dom.parentElement as DomElement;\n  while (parent) {\n    if (domWithVnodesToUpdate.has(parent)) {\n      hasParent = true;\n      break;\n    }\n    parent = parent.parentElement as DomElement;\n  }\n\n  if (!hasParent) {\n    const dom = currentVnode.dom;\n    const subscription = () => {\n      updateVnode(dom.vnode);\n      if (!dom.parentElement) {\n        subscribers.delete(subscription);\n        domWithVnodesToUpdate.delete(dom);\n      }\n    };\n    subscribers.add(subscription);\n    domWithVnodesToUpdate.add(dom);\n  }\n}\n\nfunction createStore<StateType extends State, PulsesType extends Record<string, Pulse<StateType, any>>>(\n  initialState: StateType | (() => StateType) | null,\n  pulses: PulsesType & ThisType<PulsesType & PulseContext>,\n  immutable = false\n): StorePulses<PulsesType> & {\n  state: ProxyState<StateType>;\n  on: (event: string, callback: Function) => void;\n  off: (event: string, callback: Function) => void;\n} {\n  const subscribers = new Set<Function>();\n  const domWithVnodesToUpdate = new WeakSet<DomElement>();\n\n  const boundPulses: Record<string, Function> = {};\n  for (const key in pulses) {\n    if (typeof pulses[key] !== \"function\") {\n      throw new Error(`Pulse '${key}' must be a function`);\n    }\n    if (key === \"state\") {\n      throw new Error(`A pulse cannot be named 'state'`);\n    }\n    boundPulses[key] = getPulseMethod(key);\n  }\n\n  const localState: StateType =\n    (typeof initialState === \"function\" ? initialState() : initialState) || ({} as StateType);\n\n  function isMutable() {\n    if (immutable) {\n      throw new Error(\"You need to call a pulse to modify the state\");\n    }\n  }\n\n  let currentState: StateType | null = null;\n  let pulseCallCount = 0;\n\n  const proxyState = new Proxy(localState, {\n    get: (state, prop: string) => {\n      if (currentState) {\n        return currentState[prop];\n      }\n\n      const currentEffect = effectStack[effectStack.length - 1];\n      if (currentEffect && !subscribers.has(currentEffect)) {\n        subscribers.add(currentEffect);\n      }\n\n      registerDomSubscription(subscribers, domWithVnodesToUpdate);\n\n      return state[prop];\n    },\n    set: (state, prop: string, value: any) => {\n      isMutable();\n      Reflect.set(state, prop, value);\n      return true;\n    },\n    deleteProperty: (state, prop: string) => {\n      isMutable();\n      Reflect.deleteProperty(state, prop);\n      return true;\n    }\n  });\n\n  function syncState(newState: StateType) {\n    for (const key in newState) {\n      localState[key] = immutable ? deepFreeze(newState[key]) : newState[key];\n    }\n    for (const key in localState) {\n      if (!(key in newState)) {\n        Reflect.deleteProperty(localState, key);\n      }\n    }\n  }\n\n  let debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n  function debouncedUpdate() {\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout);\n    }\n    debounceTimeout = setTimeout(() => subscribers.forEach((subscriber) => subscriber()), 0);\n  }\n\n  function setState(newState: StateType, flush = false) {\n    pulseCallCount--;\n    if (!hasChanged(localState, newState)) {\n      return;\n    }\n    if (pulseCallCount > 0 && !flush) {\n      return;\n    }\n    syncState(newState);\n    currentState = null;\n    debouncedUpdate();\n  }\n\n  function getPulseMethod(key: string) {\n    return function (this: any, ...args: any[]) {\n      pulseCallCount++;\n      if (currentState === null) {\n        currentState = deepCloneUnfreeze(localState);\n      }\n\n      // Runtime: Creamos un objeto que hereda de 'pulses' para que 'this' tenga acceso a los hermanos\n      const context = Object.create(pulses);\n\n      context.$flush = async () => {\n        if (currentState) {\n          setState(currentState, true);\n          currentState = deepCloneUnfreeze(localState);\n        }\n        await new Promise((resolve) => setTimeout(resolve, 0));\n      };\n\n      const emptyFlush = async () => {};\n\n      try {\n        const pulseResult = pulses[key].apply(context, [currentState, ...args]);\n        if (pulseResult instanceof Promise) {\n          return pulseResult\n            .then((resolvedValue) => {\n              setState(currentState as StateType);\n              context.$flush = emptyFlush;\n              return resolvedValue;\n            })\n            .catch((error) => {\n              console.error(`Error in pulse '${key}':`, error);\n              context.$flush = emptyFlush;\n              throw error;\n            });\n        } else {\n          setState(currentState);\n          context.$flush = emptyFlush;\n          return pulseResult;\n        }\n      } catch (error) {\n        console.error(`Error in pulse '${key}':`, error);\n        context.$flush = emptyFlush;\n        throw error;\n      }\n    };\n  }\n\n  syncState(localState);\n\n  const listeners: Record<string, Function[]> = {};\n  const trigger = (event: string, ...args: any[]) => {\n    if (listeners[event]) {\n      listeners[event].forEach((callback) => callback(...args));\n    }\n  };\n\n  const pulsesProxy = new Proxy(boundPulses, {\n    get: (pulses, prop: string) => {\n      if (prop === \"state\") {\n        return proxyState;\n      }\n      if (prop === \"on\") {\n        return (event: string, callback: Function) => {\n          if (!listeners[event]) {\n            listeners[event] = [];\n          }\n          listeners[event].push(callback);\n        };\n      }\n      if (prop === \"off\") {\n        return (event: string, callback: Function) => {\n          if (listeners[event]) {\n            listeners[event] = listeners[event].filter((cb) => cb !== callback);\n          }\n        };\n      }\n      if (!(prop in pulses)) {\n        throw new Error(`Pulse '${prop}' does not exist`);\n      }\n      const pulseMethod = pulses[prop];\n\n      return (...args: any[]) => {\n        const result = pulseMethod.apply(pulseMethod, args);\n        if (result instanceof Promise) {\n          return result.then((r) => {\n            trigger(\"pulse\", prop, args);\n            return r;\n          });\n        }\n        trigger(\"pulse\", prop, args);\n        return result;\n      };\n    }\n  });\n\n  return pulsesProxy as StorePulses<PulsesType> & {\n    state: ProxyState<StateType>;\n    on: (event: string, callback: Function) => void;\n    off: (event: string, callback: Function) => void;\n  };\n}\n\nexport function createPulseStore<StateType extends State, PulsesType extends Record<string, Pulse<StateType, any>>>(\n  initialState: StateType,\n  pulses: PulsesType & ThisType<PulsesType & PulseContext>\n) {\n  return createStore(initialState, pulses, true);\n}\n\nexport function createMutableStore<StateType extends State, PulsesType extends Record<string, Pulse<StateType, any>>>(\n  initialState: StateType,\n  pulses: PulsesType & ThisType<PulsesType & PulseContext>\n) {\n  console.warn(\n    \"Warning: You are working with a mutable state. All state changes made outside of a pulse will not trigger a re-render.\"\n  );\n  return createStore(initialState, pulses, false);\n}\n\nexport function createEffect(effect: Function) {\n  const runEffect = () => {\n    try {\n      effectStack.push(runEffect);\n      effect();\n    } finally {\n      effectStack.pop();\n    }\n  };\n  runEffect();\n}\n\nexport function createPulse<T>(initialValue: T): [() => T, (newValue: T | ((current: T) => T)) => void, () => void] {\n  let value = initialValue;\n  const subscribers = new Set<Function>();\n  const domWithVnodesToUpdate = new WeakSet<DomElement>();\n\n  const runSubscribers = () => {\n    subscribers.forEach((subscriber) => subscriber());\n  };\n\n  const read = (): T => {\n    const currentEffect = effectStack[effectStack.length - 1];\n    if (currentEffect && !subscribers.has(currentEffect)) {\n      subscribers.add(currentEffect);\n    }\n    registerDomSubscription(subscribers, domWithVnodesToUpdate);\n    return value;\n  };\n\n  const write = (newValue: T | ((current: T) => T)): void => {\n    const resolvedValue = typeof newValue === \"function\" ? (newValue as (current: T) => T)(value) : newValue;\n    if (!hasChanged(value, resolvedValue)) {\n      return;\n    }\n    value = resolvedValue;\n    runSubscribers();\n  };\n\n  return [read, write, runSubscribers];\n}\n"],
  "mappings": "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",
  "names": ["pulses"]
}
