{
  "version": 3,
  "sources": ["../../lib/pulses/index.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\nimport { updateVnode, VnodeWithDom, current, DomElement } from \"valyrian.js\";\nimport { deepCloneUnfreeze, deepFreeze, hasChanged } from \"valyrian.js/utils\";\n\ntype State = Record<string, any>;\n\nexport type Pulse<StateType, TReturn = unknown> = (state: StateType, ...args: any[]) => TReturn | Promise<TReturn>;\n\nexport type Pulses<StateType> = Record<string, Pulse<StateType, any> & { $flush?: () => Promise<void> }>;\n\ntype ProxyState<StateType> = StateType & { [key: string]: any };\n\nconst effectStack: Function[] = [];\n\ntype StorePulses<PulsesType extends Pulses<any>> = {\n  [K in keyof PulsesType]: PulsesType[K] extends (state: any, ...args: infer Args) => infer R\n    ? (...args: Args) => R\n    : never;\n};\n\n/** Funci\u00F3n auxiliar para registrar la suscripci\u00F3n al nodo DOM.\n *  Retorna true si se agreg\u00F3 la suscripci\u00F3n, o false si se encontr\u00F3 un nodo padre ya suscrito.\n */\nfunction registerDomSubscription(subscribers: Set<Function>, domWithVnodesToUpdate: WeakSet<DomElement>): void {\n  const currentVnode = current.vnode as VnodeWithDom;\n  if (!currentVnode || domWithVnodesToUpdate.has(currentVnode.dom)) {\n    return;\n  }\n\n  let hasParent = false;\n  let parent = currentVnode.dom.parentElement as DomElement;\n  while (parent) {\n    if (domWithVnodesToUpdate.has(parent)) {\n      hasParent = true;\n      break;\n    }\n    parent = parent.parentElement as DomElement;\n  }\n\n  // Si no hay nodo padre registrado, se crea la suscripci\u00F3n.\n  if (!hasParent) {\n    const dom = currentVnode.dom;\n    const subscription = () => {\n      updateVnode(dom.vnode);\n      if (!dom.parentElement) {\n        subscribers.delete(subscription);\n        domWithVnodesToUpdate.delete(dom);\n      }\n    };\n    subscribers.add(subscription);\n    domWithVnodesToUpdate.add(dom);\n  }\n}\n\nfunction createStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType | (() => StateType) | null,\n  pulses: PulsesType,\n  immutable = false\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  const subscribers = new Set<Function>();\n  const domWithVnodesToUpdate = new WeakSet<DomElement>();\n\n  const boundPulses: Pulses<StateType> = {};\n  for (const key in pulses) {\n    if (typeof pulses[key] !== \"function\") {\n      throw new Error(`Pulse '${key}' must be a function`);\n    }\n    if (key === \"state\") {\n      throw new Error(`A pulse cannot be named 'state'`);\n    }\n    boundPulses[key] = getPulseMethod(key);\n  }\n\n  const localState: StateType =\n    (typeof initialState === \"function\" ? initialState() : initialState) || ({} as StateType);\n\n  function isMutable() {\n    if (immutable) {\n      throw new Error(\"You need to call a pulse to modify the state\");\n    }\n  }\n\n  let currentState: StateType | null = null;\n  let pulseCallCount = 0;\n\n  const proxyState = new Proxy(localState, {\n    get: (state, prop: string) => {\n      // If we are in a pulse, we return the value of the cloned state.\n      if (currentState) {\n        return currentState[prop];\n      }\n\n      const currentEffect = effectStack[effectStack.length - 1];\n      if (currentEffect && !subscribers.has(currentEffect)) {\n        subscribers.add(currentEffect);\n      }\n\n      registerDomSubscription(subscribers, domWithVnodesToUpdate);\n\n      return state[prop];\n    },\n    set: (state, prop: string, value: any) => {\n      isMutable();\n      Reflect.set(state, prop, value);\n      return true;\n    },\n    deleteProperty: (state, prop: string) => {\n      isMutable();\n      Reflect.deleteProperty(state, prop);\n      return true;\n    }\n  });\n\n  function syncState(newState: StateType) {\n    for (const key in newState) {\n      localState[key] = immutable ? deepFreeze(newState[key]) : newState[key];\n    }\n    for (const key in localState) {\n      if (!(key in newState)) {\n        Reflect.deleteProperty(localState, key);\n      }\n    }\n  }\n\n  let debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n  function debouncedUpdate() {\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout);\n    }\n    debounceTimeout = setTimeout(() => subscribers.forEach((subscriber) => subscriber()), 0);\n  }\n\n  function setState(newState: StateType, flush = false) {\n    pulseCallCount--;\n    if (!hasChanged(localState, newState)) {\n      return;\n    }\n    if (pulseCallCount > 0 && !flush) {\n      return;\n    }\n    syncState(newState);\n    currentState = null;\n    debouncedUpdate();\n  }\n\n  function getPulseMethod(key: string) {\n    function pulseMethod(this: Pulse<StateType, any> & { $flush: () => Promise<void> }, ...args: any[]) {\n      pulseCallCount++;\n      if (currentState === null) {\n        currentState = deepCloneUnfreeze(localState);\n      }\n\n      const $flush = async () => {\n        setState(currentState as StateType, true);\n        currentState = deepCloneUnfreeze(localState);\n        await new Promise((resolve) => setTimeout(resolve, 0));\n      };\n\n      Reflect.set(this, \"$flush\", $flush);\n      const emptyFlush = async () => {};\n\n      try {\n        const pulseResult = pulses[key].apply(this, [currentState, ...args]);\n        if (pulseResult instanceof Promise) {\n          return pulseResult\n            .then((resolvedValue) => {\n              setState(currentState as StateType);\n              Reflect.set(this, \"$flush\", emptyFlush);\n              return resolvedValue;\n            })\n            .catch((error) => {\n              console.error(`Error in pulse '${key}':`, error);\n              Reflect.set(this, \"$flush\", emptyFlush);\n              throw error;\n            });\n        } else {\n          setState(currentState);\n          Reflect.set(this, \"$flush\", emptyFlush);\n          return pulseResult;\n        }\n      } catch (error) {\n        console.error(`Error in pulse '${key}':`, error);\n        Reflect.set(this, \"$flush\", emptyFlush);\n        throw error;\n      }\n    }\n\n    return pulseMethod;\n  }\n\n  syncState(localState);\n\n  const pulsesProxy = new Proxy(boundPulses, {\n    get: (pulses, prop: string) => {\n      if (prop === \"state\") {\n        return proxyState;\n      }\n      if (!(prop in pulses)) {\n        throw new Error(`Pulse '${prop}' does not exist`);\n      }\n      const pulseMethod = pulses[prop];\n\n      if (typeof pulseMethod === \"function\") {\n        return pulseMethod.bind(pulsesProxy);\n      }\n\n      return pulseMethod;\n    }\n  });\n\n  return pulsesProxy as StorePulses<PulsesType> & { state: ProxyState<StateType> };\n}\n\nexport function createPulseStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  return createStore(initialState, pulses, true);\n}\n\nexport function createMutableStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  console.warn(\n    \"Warning: You are working with a mutable state. This can lead to unpredictable behavior. All state changes made outside of a pulse will not trigger a re-render.\"\n  );\n  return createStore(initialState, pulses, false);\n}\n\nexport function createEffect(effect: Function) {\n  const runEffect = () => {\n    try {\n      effectStack.push(runEffect);\n      effect();\n    } finally {\n      effectStack.pop();\n    }\n  };\n  runEffect();\n}\n\nexport function createPulse<T>(initialValue: T): [() => T, (newValue: T | ((current: T) => T)) => void, () => void] {\n  let value = initialValue;\n  const subscribers = new Set<Function>();\n  const domWithVnodesToUpdate = new WeakSet<DomElement>();\n\n  const runSubscribers = () => {\n    subscribers.forEach((subscriber) => subscriber());\n  };\n\n  const read = (): T => {\n    const currentEffect = effectStack[effectStack.length - 1];\n    if (currentEffect && !subscribers.has(currentEffect)) {\n      subscribers.add(currentEffect);\n    }\n    registerDomSubscription(subscribers, domWithVnodesToUpdate);\n    return value;\n  };\n\n  const write = (newValue: T | ((current: T) => T)): void => {\n    const resolvedValue = typeof newValue === \"function\" ? (newValue as (current: T) => T)(value) : newValue;\n    if (!hasChanged(value, resolvedValue)) {\n      return;\n    }\n    value = resolvedValue;\n    runSubscribers();\n  };\n\n  return [read, write, runSubscribers];\n}\n"],
  "mappings": "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",
  "names": ["pulses"]
}
