{
  "version": 3,
  "sources": ["../lib/index.ts"],
  "sourcesContent": ["/* eslint-disable no-use-before-define */\n/* eslint-disable indent */\n/* eslint-disable sonarjs/cognitive-complexity */\n/* eslint-disable complexity */\n\ninterface DefaultRecord extends Record<string | number | symbol, any> {}\n\n// The VnodeProperties interface represents properties that can be passed to a virtual node.\nexport interface VnodeProperties extends DefaultRecord {\n  // A unique key for the virtual node, which can be a string or a number.\n  // This is useful for optimizing updates in a list of nodes.\n  key?: string | number;\n  // A state object that is associated with the virtual node.\n  state?: any;\n}\n\n// The DomElement interface extends the Element interface with an index signature.\n// This allows for any additional properties to be added to DOM elements.\nexport interface DomElement extends Element, DefaultRecord {}\n\n// The VnodeInterface represents a virtual node. It has a number of optional fields,\n// including a tag, props, children, and a DOM element.\nexport interface VnodeInterface extends DefaultRecord {\n  // The constructor for the virtual node. It takes a tag, props, and children as arguments.\n  // The tag can be a string, a component, or a POJO component.\n  // eslint-disable-next-line no-unused-vars\n  new (tag: string | Component | POJOComponent, props: VnodeProperties, children: Children): VnodeInterface;\n  // The tag for the virtual node. It can be a string, a component, or a POJO component.\n  tag: string | Component | POJOComponent;\n  // The props for the virtual node.\n  props: VnodeProperties;\n  // The children for the virtual node.\n  children: Children;\n  // A boolean indicating whether the virtual node is an SVG element.\n  isSVG?: boolean;\n  // The DOM element that corresponds to the virtual node.\n  dom?: DomElement;\n  // A boolean indicating whether the virtual node has been processed in the keyed diffing algorithm.\n  processed?: boolean;\n}\n\n// The VnodeWithDom interface represents a virtual node that has a DOM element associated with it.\nexport interface VnodeWithDom extends VnodeInterface {\n  dom: DomElement;\n}\n\n// The Component interface represents a function that returns a virtual node or a list of virtual nodes.\n// It can also have additional properties.\nexport interface Component extends DefaultRecord {\n  // The function that returns a virtual node or a list of virtual nodes.\n  // It can take props and children as arguments.\n  // eslint-disable-next-line no-unused-vars\n  (props?: VnodeProperties | null, ...children: any[]): VnodeInterface | Children | any;\n}\n\n// The POJOComponent interface represents a \"plain old JavaScript object\" (POJO) component.\n// It has a view function that returns a virtual node or a list of virtual nodes,\n// as well as optional props and children.\n// It can be used also to identify class instance components.\nexport interface POJOComponent extends DefaultRecord {\n  // The view function that returns a virtual node or a list of virtual nodes.\n  view: Component;\n  // The props for the component.\n  props?: VnodeProperties | null;\n  // The children for the component.\n  children?: any[];\n}\n\n// The VnodeComponentInterface represents a virtual node that has a component as its tag.\n// It has props and children, just like a regular virtual node.\nexport interface VnodeComponentInterface extends VnodeInterface {\n  tag: Component | POJOComponent;\n  props: VnodeProperties;\n  children: Children;\n}\n\n// The Children interface represents a list of virtual nodes or other values.\nexport interface Children extends Array<VnodeInterface | VnodeComponentInterface | any> {}\n\n// The Directive interface represents a function that can be applied to a virtual node.\n// It receives the value, virtual node, and old virtual node as arguments, and can return a boolean value.\n// If only the virtual node is passed, it means its the on create phase for the v-node.\n// If the old virtual node is also passed, it means its the on update phase for the v-node.\nexport interface Directive {\n  // eslint-disable-next-line no-unused-vars\n  (value: any, vnode: VnodeWithDom, oldVnode?: VnodeWithDom): void | boolean;\n}\n\n// The Directives interface is a mapping of directive names to Directive functions.\nexport interface Directives extends Record<string, Directive> {}\n\n// The ReservedProps interface is a mapping of reserved prop names to the value `true`.\n// These prop names cannot be used as custom prop names.\nexport interface ReservedProps extends Record<string, true> {}\n\n// The Current interface represents the current component and virtual node that are being processed.\nexport interface Current {\n  // The current component. It can be a component, a POJO component, or null.\n  component: Component | POJOComponent | null;\n  // The current virtual node. It must have a DOM element associated with it.\n  vnode: VnodeWithDom | null;\n  // The old virtual node. It must have a DOM element associated with it.\n  oldVnode?: VnodeWithDom | null;\n  // The current event. It can be an event or null.\n  event: Event | null;\n}\n\n// The V function is the main function for creating virtual nodes.\n// It takes a tag or component, props, and children as arguments, and returns a virtual node.\nexport interface V {\n  // eslint-disable-next-line no-unused-vars, no-use-before-define\n  (tagOrComponent: string | Component | POJOComponent, props: VnodeProperties | null, ...children: Children):\n    | VnodeInterface\n    | VnodeComponentInterface;\n  // eslint-disable-next-line no-unused-vars, no-use-before-define\n  fragment(_: any, ...children: Children): Children;\n}\n\n// 'textTag' is a constant string that is used to represent text nodes in the virtual DOM.\nconst textTag = \"#text\";\n\n// 'isNodeJs' is a boolean that is true if the code is running in a Node.js environment and false otherwise.\n// It is determined by checking if the 'process' global object is defined and has a 'versions' property.\nexport const isNodeJs = Boolean(typeof process !== \"undefined\" && process.versions && process.versions.node);\n\n// 'createDomElement' is a function that creates a new DOM element with the specified tag name.\n// If 'isSVG' is true, it creates an SVG element instead of a regular DOM element.\nexport function createDomElement(tag: string, isSVG: boolean = false): DomElement {\n  return isSVG ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag) : document.createElement(tag);\n}\n\n// 'Vnode' is a class that represents a virtual DOM node.\n// It has three properties: 'tag', 'props', and 'children'.\n// 'Vnode' is exported as an object with a type of 'VnodeInterface'.\n// The 'as unknown as VnodeInterface' is used to tell TypeScript that the 'Vnode' function has the same type as 'VnodeInterface'.\nexport const Vnode = function Vnode(this: VnodeInterface, tag: string, props: VnodeProperties, children: Children) {\n  // 'this' refers to the current instance of 'Vnode'.\n  this.tag = tag;\n  this.props = props;\n  this.children = children;\n} as unknown as VnodeInterface;\n\n// 'isComponent' is a function that returns true if the given 'component' is a valid component and false otherwise.\n// A component is either a function or an object with a 'view' function.\nexport function isComponent(component: unknown): component is Component {\n  return Boolean(\n    component && (typeof component === \"function\" || (typeof component === \"object\" && \"view\" in component))\n  );\n}\n\n// 'isVnode' is a function that returns true if the given 'object' is a 'Vnode' instance and false otherwise.\nexport const isVnode = (object?: unknown | VnodeInterface): object is VnodeInterface => {\n  // Use the 'instanceof' operator to check if 'object' is an instance of 'Vnode'.\n  return object instanceof Vnode;\n};\n\n// 'isVnodeComponent' is a function that returns true if the given 'object' is a 'Vnode' instance with a 'tag' property that is a valid component.\n// It returns false otherwise.\nexport const isVnodeComponent = (object?: unknown | VnodeComponentInterface): object is VnodeComponentInterface => {\n  // Check if 'object' is a 'Vnode' instance and its 'tag' property is a valid component.\n  return isVnode(object) && isComponent(object.tag);\n};\n\n// 'domToVnode' is a function that converts a DOM node to a 'Vnode' instance.\nexport function domToVnode(dom: any): VnodeWithDom {\n  // If the child node is a text node, create a 'Vnode' instance with the 'textTag' constant as the 'tag' property.\n  // Set the 'dom' property of the 'Vnode' instance to the child DOM node.\n  // Push the 'Vnode' instance to the 'children' array.\n  if (dom.nodeType === 3) {\n    return dom.nodeValue;\n  }\n\n  const children: VnodeWithDom[] = [];\n  // Iterate through all child nodes of 'dom'.\n  for (let i = 0, l = dom.childNodes.length; i < l; i++) {\n    const childDom = dom.childNodes[i];\n    // If the child node is an element node, recursively call 'domToVnode' to convert it to a 'Vnode' instance.\n    // Push the 'Vnode' instance to the 'children' array.\n    if (childDom.nodeType === 3) {\n      children.push(childDom.nodeValue);\n    } else if (childDom.nodeType === 1) {\n      children.push(domToVnode(childDom));\n    }\n  }\n\n  const props: VnodeProperties = {};\n  // Iterate through all attributes of 'dom'.\n  for (let i = 0, l = dom.attributes.length; i < l; i++) {\n    const attr = dom.attributes[i];\n    // Add the attribute to the 'props' object, using the attribute's name as the key and its value as the value.\n    props[attr.nodeName] = attr.nodeValue;\n  }\n\n  // Create a new 'Vnode' instance with the 'tag' property set to the lowercase version of the DOM node's tag name.\n  // Set the 'props' and 'children' properties to the 'props' and 'children' arrays respectively.\n  // Set the 'dom' property of the 'Vnode' instance to the DOM node.\n  const vnode = new Vnode(dom.tagName.toLowerCase(), props, children);\n  vnode.dom = dom;\n  return vnode as VnodeWithDom;\n}\n\n// This function takes in an HTML string and creates a virtual node representation of it\n// using the `domToVnode` function. It does this by creating a new `div` element, setting\n// its `innerHTML` to the provided HTML string, and then using `map` to iterate over the\n// `childNodes` of the `div` element, passing each one to `domToVnode` to create a virtual\n// node representation of it. The resulting array of virtual nodes is then returned.\nexport function trust(htmlString: string) {\n  const div = createDomElement(\"div\");\n  div.innerHTML = htmlString.trim();\n\n  return [].map.call(div.childNodes, (item) => domToVnode(item));\n}\n\n/* ========================================================================== */\n/* Main Component implementation                                              */\n/* ========================================================================== */\n\n// These variables are used to store the main component, the main virtual node, and whether\n// the main component is currently mounted.\nlet mainComponent: VnodeComponentInterface | null = null;\nlet mainVnode: VnodeWithDom | null = null;\nlet isMounted = false;\n\n// This object is used to store the current virtual node and component being rendered.\nexport const current: Current = {\n  vnode: null,\n  oldVnode: null,\n  component: null,\n  event: null\n};\n\n/* Reserved props ----------------------------------------------------------- */\n// This object is used to store the names of reserved props, which are props that are reserved\n// for special purposes and should not be used as regular component props.\nexport const reservedProps: Record<string, true> = {\n  key: true,\n  state: true,\n  \"v-keep\": true,\n\n  // Built in directives\n  \"v-if\": true,\n  \"v-unless\": true,\n  \"v-for\": true,\n  \"v-show\": true,\n  \"v-class\": true,\n  \"v-html\": true,\n  \"v-model\": true,\n  \"v-create\": true,\n  \"v-update\": true,\n  \"v-cleanup\": true\n};\n\n/* Mounting, Updating, Cleanup and Unmounting ------------------------------- */\n// These sets are used to store callbacks for various lifecycle events: mounting, updating,\n// cleaning up, and unmounting.\nconst onCleanupSet: Set<Function> = new Set();\nconst onMountSet: Set<Function> = new Set();\nconst onUpdateSet: Set<Function> = new Set();\nconst onUnmountSet: Set<Function> = new Set();\n\n// These functions allow users to register callbacks for the corresponding lifecycle events.\nexport function onMount(callback: Function) {\n  if (!isMounted) {\n    onMountSet.add(callback);\n  }\n}\n\nexport function onUpdate(callback: Function) {\n  onUpdateSet.add(callback);\n}\n\nexport function onCleanup(callback: Function) {\n  onCleanupSet.add(callback);\n}\n\nexport function onUnmount(callback: Function) {\n  if (!isMounted) {\n    onUnmountSet.add(callback);\n  }\n}\n\n// This function is used to call all the callbacks in a given set.\nfunction callSet(set: Set<Function>) {\n  for (const callback of set) {\n    callback();\n  }\n\n  set.clear();\n}\n\n/* Event listener ----------------------------------------------------------- */\n\n// This object stores the names of event listeners that have been added\nconst eventListenerNames: Record<string, true> = {};\n\n// This function is called when an event occurs\nfunction eventListener(e: Event) {\n  // Set the current event to the event that occurred so that it can be prevented if necessary\n  current.event = e;\n\n  // Convert the target of the event to a DOM element\n  let dom = e.target as DomElement;\n\n  // Create the name of the event listener by adding \"v-on\" to the event type\n  const name = `v-on${e.type}`;\n\n  // Keep going up the DOM tree until we find an element with an event listener\n  // matching the event type\n  while (dom) {\n    if (dom[name]) {\n      // Call the event listener function\n      dom[name](e, dom);\n\n      // If the default action of the event hasn't been prevented, update the DOM\n      if (!e.defaultPrevented) {\n        update();\n      }\n      return;\n    }\n    dom = dom.parentNode as DomElement;\n  }\n\n  current.event = null;\n}\n\n/* Directives --------------------------------------------------------------- */\n\n// This function creates a directive that hides an element based on a condition\nconst hideDirective = (test: boolean) => (bool: boolean, vnode: VnodeWithDom, oldnode?: VnodeInterface) => {\n  // If test is true, use the value of bool. Otherwise, use the opposite of bool.\n  const value = test ? bool : !bool;\n\n  // If the value is true, hide the element by replacing it with a text node\n  if (value) {\n    const parentNode = vnode.dom?.parentNode;\n    if (parentNode) {\n      const newdom = document.createTextNode(\"\");\n      parentNode.replaceChild(newdom, vnode.dom);\n    }\n\n    return false;\n  }\n};\n\n// This object stores all the available directives\nexport const directives: Directives = {\n  // The \"v-if\" directive hides an element if the given condition is false\n  \"v-if\": hideDirective(false),\n\n  // The \"v-unless\" directive hides an element if the given condition is true\n  \"v-unless\": hideDirective(true),\n\n  // The \"v-for\" directive creates a loop and applies a callback function to each item in the loop\n  \"v-for\": (set: unknown[], vnode: VnodeWithDom) => {\n    const newChildren: VnodeInterface[] = [];\n    const callback = vnode.children[0];\n    for (let i = 0, l = set.length; i < l; i++) {\n      newChildren.push(callback(set[i], i));\n    }\n    vnode.children = newChildren;\n  },\n\n  // The \"v-show\" directive shows or hides an element by setting the \"display\" style property\n  \"v-show\": (bool: boolean, vnode: VnodeWithDom) => {\n    (\n      vnode.dom as unknown as {\n        style: { display: string };\n      }\n    ).style.display = bool ? \"\" : \"none\";\n  },\n\n  // The \"v-class\" directive adds or removes class names from an element based on a condition\n  \"v-class\": (classes: { [x: string]: boolean }, vnode: VnodeWithDom) => {\n    // Loop through all the class names in the classes object\n    for (const name in classes) {\n      // Add or remove the class name from the element's class list based on the value in the classes object\n      (vnode.dom as DomElement).classList.toggle(name, classes[name]);\n    }\n  },\n\n  // The \"v-html\" directive sets the inner HTML of an element to the given HTML string\n  \"v-html\": (html: string, vnode: VnodeWithDom) => {\n    // Set the children of the vnode to a trusted version of the HTML string\n    vnode.children = [trust(html)];\n  },\n\n  // The \"v-model\" directive binds the value of an input element to a model property\n  \"v-model\": ([model, property, event]: any[], vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => {\n    let value;\n    // This function updates the model property when the input element's value changes\n    let handler = (e: Event) => (model[property] = (e.target as DomElement & Record<string, any>).value);\n    if (vnode.tag === \"input\") {\n      // If the element is an input, use the \"input\" event by default\n      event = event || \"oninput\";\n      // Depending on the type of input element, use a different handler function\n      switch (vnode.props.type) {\n        case \"checkbox\": {\n          if (Array.isArray(model[property])) {\n            // If the model property is an array, add or remove the value from the array when the checkbox is checked or unchecked\n            handler = (e: Event) => {\n              const val = (e.target as DomElement & Record<string, any>).value;\n              const idx = model[property].indexOf(val);\n              if (idx === -1) {\n                model[property].push(val);\n              } else {\n                model[property].splice(idx, 1);\n              }\n            };\n            // If the value is in the array, set the checkbox to be checked\n            value = model[property].indexOf(vnode.dom.value) !== -1;\n          } else if (\"value\" in vnode.props) {\n            // If the input element has a \"value\" attribute, use it to determine the checked state\n            handler = () => {\n              if (model[property] === vnode.props.value) {\n                model[property] = null;\n              } else {\n                model[property] = vnode.props.value;\n              }\n            };\n            value = model[property] === vnode.props.value;\n          } else {\n            // If there is no \"value\" attribute, use a boolean value for the model property\n            handler = () => (model[property] = !model[property]);\n            value = model[property];\n          }\n          // Set the \"checked\" attribute on the input element\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"checked\", value, vnode);\n          break;\n        }\n        case \"radio\": {\n          // If the element is a radio button, set the \"checked\" attribute based on the value of the model property\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"checked\", model[property] === vnode.dom.value, vnode);\n          break;\n        }\n        default: {\n          // For all other input types, set the \"value\" attribute based on the value of the model property\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"value\", model[property], vnode);\n        }\n      }\n    } else if (vnode.tag === \"select\") {\n      // If the element is a select element, use the \"click\" event by default\n      event = event || \"onclick\";\n      if (vnode.props.multiple) {\n        // If the select element allows multiple selections, update the model property with an array of selected values\n        handler = (e: Event & Record<string, any>) => {\n          const val = (e.target as DomElement & Record<string, any>).value;\n          if (e.ctrlKey) {\n            // If the Ctrl key is pressed, add or remove the value from the array\n            const idx = model[property].indexOf(val);\n            if (idx === -1) {\n              model[property].push(val);\n            } else {\n              model[property].splice(idx, 1);\n            }\n          } else {\n            // If the Ctrl key is not pressed, set the model property to an array with the selected value\n            model[property].splice(0, model[property].length);\n            model[property].push(val);\n          }\n        };\n        // Set the \"selected\" attribute on the options based on whether they are in the model property array\n        vnode.children.forEach((child: VnodeInterface) => {\n          if (child.tag === \"option\") {\n            const value = \"value\" in child.props ? child.props.value : child.children.join(\"\").trim();\n            child.props.selected = model[property].indexOf(value) !== -1;\n          }\n        });\n      } else {\n        // If the select element does not allow multiple selections, set the \"selected\" attribute on the options based on the value of the model property\n        vnode.children.forEach((child: VnodeInterface) => {\n          if (child.tag === \"option\") {\n            const value = \"value\" in child.props ? child.props.value : child.children.join(\"\").trim();\n            child.props.selected = value === model[property];\n          }\n        });\n      }\n    } else if (vnode.tag === \"textarea\") {\n      // If the element is a textarea, use the \"input\" event by default\n      event = event || \"oninput\";\n      // Set the textarea's content to the value of the model property\n      vnode.children = [model[property]];\n    }\n\n    // We assume that the prev handler if any will not be changed by the user across patchs\n    const prevHandler = vnode.props[event];\n\n    // Set the event handler on the element\n    // eslint-disable-next-line no-use-before-define\n    sharedSetAttribute(\n      event,\n      (e: Event) => {\n        handler(e);\n\n        // If the previous handler is defined, call it after the model has been updated\n        if (prevHandler) {\n          prevHandler(e);\n        }\n      },\n      vnode,\n      oldVnode\n    );\n  },\n\n  // The \"v-create\" directive is called when a new virtual node is created.\n  // The provided callback function is called with the new virtual node as an argument.\n  // This directive is only called once per virtual node, when it is first created.\n  // eslint-disable-next-line no-unused-vars\n  \"v-create\": (callback: (vnode: VnodeWithDom) => void, vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => {\n    // If this is not an update, call the callback function with the new virtual node\n    if (!oldVnode) {\n      const cleanup = callback(vnode);\n\n      // If the callback function returns a function, call it when the update is gonna be cleaned up\n      if (typeof cleanup === \"function\") {\n        onCleanup(cleanup);\n      }\n    }\n  },\n\n  // The \"v-update\" directive is called when an existing virtual node is updated.\n  // The provided callback function is called with the new and old virtual nodes as arguments.\n  // This directive is only called once per virtual node update.\n  \"v-update\": (\n    // eslint-disable-next-line no-unused-vars\n    callback: (vnode: VnodeWithDom, oldVnode: VnodeWithDom) => void,\n    vnode: VnodeWithDom,\n    oldVnode?: VnodeWithDom\n  ) => {\n    // If this is an update, call the callback function with the new and old virtual nodes\n    if (oldVnode) {\n      const cleanup = callback(vnode, oldVnode);\n\n      // If the callback function returns a function, call it when the update is gonna be cleaned up\n      if (typeof cleanup === \"function\") {\n        onCleanup(cleanup);\n      }\n    }\n  },\n\n  // The \"v-cleanup\" directive is called when the update is cleaned up.\n  // The provided callback function is called with the old virtual node as an argument.\n  // This directive is only called once per virtual node, when the update is cleaned up.\n  \"v-cleanup\": (\n    // eslint-disable-next-line no-unused-vars\n    callback: (vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => void,\n    vnode: VnodeWithDom,\n    oldVnode?: VnodeWithDom\n  ) => {\n    // Add the callback function to the list of cleanup functions to be called when the update is cleaned up\n    onCleanup(() => callback(vnode, oldVnode));\n  }\n};\n// Add a directive to the global directives object, with the key being the name\n// preceded by \"v-\". Also add the name to the global reservedProps object.\nexport function directive(name: string, directive: Directive) {\n  const directiveName = `v-${name}`;\n  directives[directiveName] = directive;\n  reservedProps[directiveName] = true;\n}\n\n// Set an attribute on a virtual DOM node and update the actual DOM element.\n// If the attribute value is a function, add an event listener for the attribute\n// name to the DOM element represented by mainVnode.\n// If oldVnode is provided, compare the new attribute value to the old value\n// and only update the attribute if the values are different.\nfunction sharedSetAttribute(name: string, value: any, newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void | boolean {\n  // If the attribute value is a function, add an event listener for the attribute\n  // name to the DOM element represented by mainVnode.\n  if (typeof value === \"function\") {\n    // Only add the event listener if it hasn't been added yet.\n    if (name in eventListenerNames === false) {\n      (mainVnode as VnodeWithDom).dom.addEventListener(name.slice(2), eventListener);\n      eventListenerNames[name] = true;\n    }\n    newVnode.dom[`v-${name}`] = value;\n    return;\n  }\n\n  // If the attribute is present on the DOM element and newVnode is not an SVG,\n  // update the attribute if the value has changed.\n  if (newVnode.isSVG === false && name in newVnode.dom) {\n    // eslint-disable-next-line eqeqeq\n    if (newVnode.dom[name] != value) {\n      newVnode.dom[name] = value;\n    }\n    return;\n  }\n\n  // If oldVnode is not provided or the attribute value has changed, update the\n  // attribute on the DOM element.\n  if (!oldVnode || value !== oldVnode.props[name]) {\n    if (value === false) {\n      newVnode.dom.removeAttribute(name);\n    } else {\n      newVnode.dom.setAttribute(name, value);\n    }\n  }\n}\n\n// Set an attribute on a virtual DOM node and update the actual DOM element.\n// Skip the attribute if it is in the reservedProps object.\nexport function setAttribute(name: string, value: any, newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  if (reservedProps[name]) {\n    return;\n  }\n  newVnode.props[name] = value;\n  sharedSetAttribute(name, value, newVnode, oldVnode);\n}\n\n// Update the attributes on a virtual DOM node. If oldVnode is provided, remove\n// attributes from the DOM element that are not present in newVnode.props but are\n// present in oldVnode.props. Then, iterate over the attributes in newVnode.props\n// and update the DOM element with the attributes using the sharedSetAttribute\n// function. If an attribute is in the reservedProps object and has a corresponding\n// directive in the directives object, call the directive with the attribute value\n// and the two virtual DOM nodes as arguments. If the directive returns false, exit\n// the loop.\nexport function updateAttributes(newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  // If oldVnode is provided, remove attributes from the DOM element that are not\n  // present in newVnode.props but are present in oldVnode.props.\n  if (oldVnode) {\n    for (const name in oldVnode.props) {\n      if (!newVnode.props[name] && !eventListenerNames[name] && !reservedProps[name]) {\n        if (newVnode.isSVG === false && name in newVnode.dom) {\n          newVnode.dom[name] = null;\n        } else {\n          newVnode.dom.removeAttribute(name);\n        }\n      }\n    }\n  }\n\n  // Iterate over the attributes in newVnode.props and update the DOM element with\n  // the attributes using the sharedSetAttribute function.\n  for (const name in newVnode.props) {\n    if (reservedProps[name]) {\n      // If there is a directive for the attribute, call it with the attribute value\n      // and the two virtual DOM nodes as arguments. If the directive returns false,\n      // exit the loop.\n      if (directives[name] && directives[name](newVnode.props[name], newVnode, oldVnode) === false) {\n        break;\n      }\n      continue;\n    }\n    sharedSetAttribute(name, newVnode.props[name], newVnode, oldVnode);\n  }\n}\n\n/* patch ------------------------------------------------------------------- */\n\n// Patch a DOM node with a new VNode tree\nexport function patch(newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  // If the new tree has no children, set the text content of the parent DOM element to an empty string\n  if (newVnode.children.length === 0) {\n    newVnode.dom.textContent = \"\";\n    return;\n  }\n\n  // Get the children of the new and old virtual DOM nodes\n  const newTree = newVnode.children;\n  const oldTree = oldVnode?.children || [];\n  // Get the length of the old tree\n  const oldTreeLength = oldTree.length;\n  // Get the length of the new tree\n  let newTreeLength = newTree.length;\n  // Set the global current object to the new and old virtual DOM nodes\n  current.vnode = newVnode;\n  current.oldVnode = oldVnode;\n\n  // Flatten the new tree\n  // Take into account that is necessary to flatten the tree before the patch process\n  // to let the hooks and signals work properly\n  let i = 0;\n  while (i < newTreeLength) {\n    const newChild = newTree[i];\n\n    // If the new child is a Vnode and is not a text node\n    if (newChild instanceof Vnode) {\n      // If the tag of the new child is not a string, it is a component\n      if (typeof newChild.tag !== \"string\") {\n        // Set the current component to the tag of the new child\n        current.component = newChild.tag;\n        // Replace the new child with the result of calling its view or bind method, passing in the props and children as arguments\n        newTree.splice(\n          i,\n          1,\n          (\"view\" in newChild.tag ? newChild.tag.view.bind(newChild.tag) : newChild.tag.bind(newChild.tag))(\n            newChild.props,\n            ...newChild.children\n          )\n        );\n        newTreeLength = newTree.length;\n        continue;\n      } else {\n        i++;\n      }\n      // If the new child is an array, flatten it and continue the loop\n    } else if (Array.isArray(newChild)) {\n      newTree.splice(i, 1, ...newChild);\n      newTreeLength = newTree.length;\n      // If the new child is null or undefined, remove it from the new tree and continue the loop\n    } else if (newChild == null) {\n      newTree.splice(i, 1);\n      newTreeLength = newTree.length;\n    } else {\n      // If the new child is not a Vnode or an array, it is a text node\n      // just continue the loop\n      i++;\n    }\n  }\n\n  // If the new tree has no children, set the text content of the parent DOM element to an empty string\n  if (newTreeLength === 0) {\n    newVnode.dom.textContent = \"\";\n    return;\n  }\n\n  // If the old tree has children and the first child of the new tree is a VNode with a \"key\"\n  // attribute and the first child of the old tree is a VNode with a \"key\" attribute, update\n  // the DOM element in place by comparing the keys of the nodes in the trees.\n  if (\n    oldTreeLength > 0 &&\n    newTree[0] instanceof Vnode &&\n    oldTree[0] instanceof Vnode &&\n    \"key\" in newTree[0].props &&\n    \"key\" in oldTree[0].props\n  ) {\n    const oldKeyedList: Record<string, number> = {};\n    const newKeyedList: Record<string, number> = {};\n    const childNodes = newVnode.dom.childNodes;\n\n    // Create key maps while also handling removal of nodes not present in newTree\n    for (let i = 0; i < oldTreeLength; i++) {\n      oldKeyedList[oldTree[i].props.key] = i;\n      if (i < newTreeLength) {\n        newKeyedList[newTree[i].props.key] = i;\n      }\n    }\n\n    for (let i = 0; i < newTreeLength; i++) {\n      const newChild = newTree[i];\n      const oldChildIndex = oldKeyedList[newChild.props.key];\n      const oldChild = oldTree[oldChildIndex];\n      let shouldPatch = true;\n\n      if (oldChild) {\n        newChild.dom = oldChild.dom;\n        if (\"v-keep\" in newChild.props && newChild.props[\"v-keep\"] === oldChild.props[\"v-keep\"]) {\n          newChild.children = oldChild.children;\n          shouldPatch = false;\n        } else {\n          updateAttributes(newChild, oldChild);\n        }\n      } else {\n        newChild.dom = createDomElement(newChild.tag, newChild.isSVG);\n        updateAttributes(newChild);\n      }\n\n      const currentNode = childNodes[i];\n      if (!currentNode) {\n        newVnode.dom.appendChild(newChild.dom);\n      } else if (currentNode !== newChild.dom) {\n        newVnode.dom.replaceChild(newChild.dom, currentNode);\n      }\n\n      shouldPatch && patch(newChild, oldChild);\n    }\n\n    // Remove nodes that don't exist in newTree\n    for (let i = newTreeLength; i < oldTreeLength; i++) {\n      if (!newKeyedList[oldTree[i].props.key]) {\n        const domToRemove = oldTree[i].dom;\n        domToRemove.parentNode && domToRemove.parentNode.removeChild(domToRemove);\n      }\n    }\n    return;\n  }\n\n  // Patch the the old tree\n  for (let i = 0; i < newTreeLength; i++) {\n    const newChild = newTree[i];\n    const oldChild = oldTree[i];\n    const isGreaterThanOldTreeLength = i >= oldTreeLength;\n\n    if (newChild instanceof Vnode === false) {\n      if (isGreaterThanOldTreeLength || oldChild instanceof Vnode) {\n        // If there's no corresponding old child, create a new text node for the new child\n        const dom = document.createTextNode(newChild as string);\n\n        if (isGreaterThanOldTreeLength) {\n          // Append the new child to the dom\n          newVnode.dom.appendChild(dom);\n        } else {\n          newVnode.dom.replaceChild(dom, newVnode.dom.childNodes[i]);\n        }\n        continue;\n      }\n\n      // If the old child is not a vnode\n      // eslint-disable-next-line eqeqeq\n      if (newVnode.dom.childNodes[i].textContent != newChild) {\n        newVnode.dom.childNodes[i].textContent = newChild as string;\n      }\n      continue;\n    }\n\n    // Set the isSVG flag for the new child if it is an SVG element or if the parent is an SVG element\n    newChild.isSVG = newVnode.isSVG || newChild.tag === \"svg\";\n\n    if (isGreaterThanOldTreeLength || oldChild instanceof Vnode === false || newChild.tag !== oldChild.tag) {\n      // If there's no corresponding old child, create a new dom element for the new child\n      newChild.dom = createDomElement(newChild.tag as string, newChild.isSVG);\n\n      if (isGreaterThanOldTreeLength) {\n        // Append the new child to the dom\n        newVnode.dom.appendChild(newChild.dom);\n      } else {\n        newVnode.dom.replaceChild(newChild.dom, newVnode.dom.childNodes[i]);\n      }\n\n      // Update the attributes of the new child\n      updateAttributes(newChild as VnodeWithDom);\n\n      // Recursively patch the new child\n      patch(newChild as VnodeWithDom);\n      continue;\n    }\n\n    // Set the dom property of the new child to the dom property of the old child\n    newChild.dom = oldChild.dom;\n    // If the v-keep prop is the same for both the new and old child, set the children of the new child to the children of the old child\n    if (\"v-keep\" in newChild.props && newChild.props[\"v-keep\"] === oldChild.props[\"v-keep\"]) {\n      newChild.children = oldChild.children;\n      continue;\n    }\n\n    // Update the attributes of the new child based on the old child\n    updateAttributes(newChild as VnodeWithDom, oldChild as VnodeWithDom);\n    // Recursively patch the new and old children\n    patch(newChild as VnodeWithDom, oldChild as VnodeWithDom);\n  }\n\n  // Remove any old children that are no longer present in the new tree\n  for (; newTreeLength < oldTreeLength; newTreeLength++) {\n    newVnode.dom.removeChild(oldTree[newTreeLength].dom);\n  }\n}\n\n// Update the main Vnode\nexport function update(): void | string {\n  // If the main Vnode exists\n  if (mainVnode) {\n    // Call any cleanup functions that are registered with the onCleanupSet set\n    callSet(onCleanupSet);\n    // Store a reference to the old main Vnode\n    const oldMainVnode = mainVnode;\n    // Create a new main Vnode with the main component as its only child\n    mainVnode = new Vnode(oldMainVnode.tag, oldMainVnode.props, [mainComponent]) as VnodeWithDom;\n    mainVnode.dom = oldMainVnode.dom;\n    mainVnode.isSVG = oldMainVnode.isSVG;\n\n    // Recursively patch the new and old main Vnodes\n    patch(mainVnode, oldMainVnode);\n\n    // Call any update or mount functions that are registered with the onUpdateSet or onMountSet set\n    callSet(isMounted ? onUpdateSet : onMountSet);\n\n    // Set the isMounted flag to true\n    isMounted = true;\n\n    // Reset the current vnode, oldVnode, and component properties\n    current.vnode = null;\n    current.oldVnode = null;\n    current.component = null;\n\n    // If the code is running in a Node.js environment, return the inner HTML of the main Vnode's dom element\n    if (isNodeJs) {\n      return mainVnode.dom.innerHTML;\n    }\n  }\n}\n\n// Update custom Vnode\n// It is assumed that a first mount has already occurred, so,\n// the oldVnode is not null and the dom property of the oldVnode is not null\n// You need to set the dom property of the newVnode to the dom property of the oldVnode\n// The same with the isSVG property\n// Prefer this function over patch to allow for cleanup, onUpdate and onMount sets to be called\nexport function updateVnode(vnode: VnodeWithDom, oldVnode: VnodeWithDom): string | void {\n  // Call any cleanup functions that are registered with the onCleanupSet set\n  callSet(onCleanupSet);\n\n  // Recursively patch the new and old main Vnodes\n  patch(vnode, oldVnode);\n\n  // Set the oldVnode's tag, props, children, dom, and isSVG properties to the newVnode's tag, props, children, dom, and isSVG properties\n  // This is necessary to allow for the oldVnode to be used as the newVnode in the next update with the normal update function\n  oldVnode.tag = vnode.tag;\n  oldVnode.props = { ...vnode.props };\n  oldVnode.children = [...vnode.children];\n  oldVnode.dom = vnode.dom;\n  oldVnode.isSVG = vnode.isSVG;\n\n  // Call any update or mount functions that are registered with the onUpdateSet or onMountSet set\n  callSet(isMounted ? onUpdateSet : onMountSet);\n\n  // Set the isMounted flag to true\n  isMounted = true;\n\n  // Reset the current vnode, oldVnode, and component properties\n  current.vnode = null;\n  current.oldVnode = null;\n  current.component = null;\n\n  if (isNodeJs) {\n    return vnode.dom.innerHTML;\n  }\n}\n\n// Unmount the main Vnode\nexport function unmount() {\n  // If the main Vnode exists\n  if (mainVnode) {\n    // Set the main component to a null Vnode\n    mainComponent = new Vnode(() => null, {}, []) as VnodeComponentInterface;\n    // Update the main Vnode\n    const result = update();\n    // Call any unmount functions that are registered with the onUnmountSet set\n    callSet(onUnmountSet);\n\n    // Remove any event listeners that were added to the main Vnode's dom element\n    for (const name in eventListenerNames) {\n      mainVnode.dom.removeEventListener(name.slice(2).toLowerCase(), eventListener);\n      Reflect.deleteProperty(eventListenerNames, name);\n    }\n\n    // Reset the main component and main Vnode\n    mainComponent = null;\n    mainVnode = null;\n    // Set the isMounted flag to false\n    isMounted = false;\n    // Reset the current vnode, oldVnode, and component properties\n    current.vnode = null;\n    current.oldVnode = null;\n    current.component = null;\n    // Return the result of updating the main Vnode\n    return result;\n  }\n}\n// This function takes in a DOM element or a DOM element selector and a component to be mounted on it.\nexport function mount(dom: string | DomElement, component: any) {\n  // Check if the 'dom' argument is a string. If it is, select the first element that matches the given selector.\n  // Otherwise, use the 'dom' argument as the container.\n  const container =\n    typeof dom === \"string\"\n      ? isNodeJs\n        ? createDomElement(dom, dom === \"svg\")\n        : document.querySelectorAll(dom)[0]\n      : dom;\n\n  // Check if the 'component' argument is a Vnode component or a regular component.\n  // If it's a regular component, create a new Vnode component using the 'component' argument as the tag.\n  // If it's not a component at all, create a new Vnode component with the 'component' argument as the rendering function.\n  const vnodeComponent = isVnodeComponent(component)\n    ? component\n    : isComponent(component)\n    ? new Vnode(component, {}, [])\n    : new Vnode(() => component, {}, []);\n\n  // If a main component already exists and it's not the same as the current 'vnodeComponent', unmount it.\n  if (mainComponent && mainComponent.tag !== vnodeComponent.tag) {\n    unmount();\n  }\n\n  // Set the 'vnodeComponent' as the main component.\n  mainComponent = vnodeComponent as VnodeComponentInterface;\n  // Convert the container element to a Vnode.\n  mainVnode = domToVnode(container);\n  // Update the DOM with the new component.\n  return update();\n}\n\n// This is a utility function for creating Vnode objects.\n// It takes in a tag or component, and optional props and children arguments.\nexport const v: V = (tagOrComponent, props, ...children) => {\n  // Return a new Vnode object using the given arguments.\n  return new Vnode(tagOrComponent, props || {}, children);\n};\n\n// This utility function creates a fragment Vnode.\n// It takes in a placeholder and the children arguments, returns only the children.\nv.fragment = (_: VnodeProperties, ...children: Children) => children;\n"],
  "mappings": "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",
  "names": ["Vnode", "value", "directive", "i"]
}
