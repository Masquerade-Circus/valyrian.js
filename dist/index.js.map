{
  "version": 3,
  "sources": ["../lib/index.ts"],
  "sourcesContent": ["/* eslint-disable no-use-before-define */\n/* eslint-disable indent */\n/* eslint-disable sonarjs/cognitive-complexity */\n/* eslint-disable complexity */\n\ninterface DefaultRecord extends Record<string | number | symbol, any> {}\n\n// The VnodeProperties interface represents properties that can be passed to a virtual node.\nexport interface VnodeProperties extends DefaultRecord {\n  // A unique key for the virtual node, which can be a string or a number.\n  // This is useful for optimizing updates in a list of nodes.\n  key?: string | number;\n  // A state object that is associated with the virtual node.\n  state?: any;\n}\n\n// The DomElement interface extends the Element interface with an index signature.\n// This allows for any additional properties to be added to DOM elements.\nexport interface DomElement extends Element, DefaultRecord {}\n\n// The VnodeInterface represents a virtual node. It has a number of optional fields,\n// including a tag, props, children, and a DOM element.\nexport interface VnodeInterface extends DefaultRecord {\n  // The constructor for the virtual node. It takes a tag, props, and children as arguments.\n  // The tag can be a string, a component, or a POJO component.\n  // eslint-disable-next-line no-unused-vars\n  new (tag: string | Component | POJOComponent, props: VnodeProperties, children: Children): VnodeInterface;\n  // The tag for the virtual node. It can be a string, a component, or a POJO component.\n  tag: string | Component | POJOComponent;\n  // The props for the virtual node.\n  props: VnodeProperties;\n  // The children for the virtual node.\n  children: Children;\n  // A boolean indicating whether the virtual node is an SVG element.\n  isSVG?: boolean;\n  // The DOM element that corresponds to the virtual node.\n  dom?: DomElement;\n  // A boolean indicating whether the virtual node has been processed in the keyed diffing algorithm.\n  processed?: boolean;\n}\n\n// The VnodeWithDom interface represents a virtual node that has a DOM element associated with it.\nexport interface VnodeWithDom extends VnodeInterface {\n  dom: DomElement;\n}\n\n// The Component interface represents a function that returns a virtual node or a list of virtual nodes.\n// It can also have additional properties.\nexport interface Component extends DefaultRecord {\n  // The function that returns a virtual node or a list of virtual nodes.\n  // It can take props and children as arguments.\n  // eslint-disable-next-line no-unused-vars\n  (props?: VnodeProperties | null, ...children: any[]): VnodeInterface | Children | any;\n}\n\n// The POJOComponent interface represents a \"plain old JavaScript object\" (POJO) component.\n// It has a view function that returns a virtual node or a list of virtual nodes,\n// as well as optional props and children.\n// It can be used also to identify class instance components.\nexport interface POJOComponent extends DefaultRecord {\n  // The view function that returns a virtual node or a list of virtual nodes.\n  view: Component;\n  // The props for the component.\n  props?: VnodeProperties | null;\n  // The children for the component.\n  children?: any[];\n}\n\n// The VnodeComponentInterface represents a virtual node that has a component as its tag.\n// It has props and children, just like a regular virtual node.\nexport interface VnodeComponentInterface extends VnodeInterface {\n  tag: Component | POJOComponent;\n  props: VnodeProperties;\n  children: Children;\n}\n\n// The Children interface represents a list of virtual nodes or other values.\nexport interface Children extends Array<VnodeInterface | VnodeComponentInterface | any> {}\n\n// The Directive interface represents a function that can be applied to a virtual node.\n// It receives the value, virtual node, and old virtual node as arguments, and can return a boolean value.\n// If only the virtual node is passed, it means its the on create phase for the v-node.\n// If the old virtual node is also passed, it means its the on update phase for the v-node.\nexport interface Directive {\n  // eslint-disable-next-line no-unused-vars\n  (value: any, vnode: VnodeWithDom, oldVnode?: VnodeWithDom): void | boolean;\n}\n\n// The Directives interface is a mapping of directive names to Directive functions.\nexport interface Directives extends Record<string, Directive> {}\n\n// The ReservedProps interface is a mapping of reserved prop names to the value `true`.\n// These prop names cannot be used as custom prop names.\nexport interface ReservedProps extends Record<string, true> {}\n\n// The Current interface represents the current component and virtual node that are being processed.\nexport interface Current {\n  // The current component. It can be a component, a POJO component, or null.\n  component: Component | POJOComponent | null;\n  // The current virtual node. It must have a DOM element associated with it.\n  vnode: VnodeWithDom | null;\n  // The old virtual node. It must have a DOM element associated with it.\n  oldVnode?: VnodeWithDom | null;\n  // The current event. It can be an event or null.\n  event: Event | null;\n}\n\n// The V function is the main function for creating virtual nodes.\n// It takes a tag or component, props, and children as arguments, and returns a virtual node.\nexport interface V {\n  // eslint-disable-next-line no-unused-vars, no-use-before-define\n  (tagOrComponent: string | Component | POJOComponent, props: VnodeProperties | null, ...children: Children):\n    | VnodeInterface\n    | VnodeComponentInterface;\n  // eslint-disable-next-line no-unused-vars, no-use-before-define\n  fragment(_: any, ...children: Children): Children;\n}\n\n// 'textTag' is a constant string that is used to represent text nodes in the virtual DOM.\nconst textTag = \"#text\";\n\n// 'isNodeJs' is a boolean that is true if the code is running in a Node.js environment and false otherwise.\n// It is determined by checking if the 'process' global object is defined and has a 'versions' property.\nexport let isNodeJs = Boolean(typeof process !== \"undefined\" && process.versions && process.versions.node);\n\n// 'createDomElement' is a function that creates a new DOM element with the specified tag name.\n// If 'isSVG' is true, it creates an SVG element instead of a regular DOM element.\nexport function createDomElement(tag: string, isSVG: boolean = false): DomElement {\n  return isSVG ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag) : document.createElement(tag);\n}\n\n// 'Vnode' is a class that represents a virtual DOM node.\n// It has three properties: 'tag', 'props', and 'children'.\n// 'Vnode' is exported as an object with a type of 'VnodeInterface'.\n// The 'as unknown as VnodeInterface' is used to tell TypeScript that the 'Vnode' function has the same type as 'VnodeInterface'.\nexport const Vnode = function Vnode(this: VnodeInterface, tag: string, props: VnodeProperties, children: Children) {\n  // 'this' refers to the current instance of 'Vnode'.\n  this.tag = tag;\n  this.props = props;\n  this.children = children;\n} as unknown as VnodeInterface;\n\n// 'isComponent' is a function that returns true if the given 'component' is a valid component and false otherwise.\n// A component is either a function or an object with a 'view' function.\nexport function isComponent(component: unknown): component is Component {\n  return Boolean(\n    component && (typeof component === \"function\" || (typeof component === \"object\" && \"view\" in component))\n  );\n}\n\n// 'isVnode' is a function that returns true if the given 'object' is a 'Vnode' instance and false otherwise.\nexport const isVnode = (object?: unknown | VnodeInterface): object is VnodeInterface => {\n  // Use the 'instanceof' operator to check if 'object' is an instance of 'Vnode'.\n  return object instanceof Vnode;\n};\n\n// 'isVnodeComponent' is a function that returns true if the given 'object' is a 'Vnode' instance with a 'tag' property that is a valid component.\n// It returns false otherwise.\nexport const isVnodeComponent = (object?: unknown | VnodeComponentInterface): object is VnodeComponentInterface => {\n  // Check if 'object' is a 'Vnode' instance and its 'tag' property is a valid component.\n  return isVnode(object) && isComponent(object.tag);\n};\n\n// 'domToVnode' is a function that converts a DOM node to a 'Vnode' instance.\nexport function domToVnode(dom: any): VnodeWithDom {\n  // If the child node is a text node, create a 'Vnode' instance with the 'textTag' constant as the 'tag' property.\n  // Set the 'dom' property of the 'Vnode' instance to the child DOM node.\n  // Push the 'Vnode' instance to the 'children' array.\n  if (dom.nodeType === 3) {\n    let vnode = new Vnode(textTag, {}, [dom.nodeValue]);\n    vnode.dom = dom;\n    return vnode as VnodeWithDom;\n  }\n\n  let children: VnodeWithDom[] = [];\n  // Iterate through all child nodes of 'dom'.\n  for (let i = 0, l = dom.childNodes.length; i < l; i++) {\n    let childDom = dom.childNodes[i];\n    // If the child node is an element node, recursively call 'domToVnode' to convert it to a 'Vnode' instance.\n    // Push the 'Vnode' instance to the 'children' array.\n    if (childDom.nodeType === 1 || childDom.nodeType === 3) {\n      children.push(domToVnode(childDom));\n    }\n  }\n\n  let props: VnodeProperties = {};\n  // Iterate through all attributes of 'dom'.\n  for (let i = 0, l = dom.attributes.length; i < l; i++) {\n    let attr = dom.attributes[i];\n    // Add the attribute to the 'props' object, using the attribute's name as the key and its value as the value.\n    props[attr.nodeName] = attr.nodeValue;\n  }\n\n  // Create a new 'Vnode' instance with the 'tag' property set to the lowercase version of the DOM node's tag name.\n  // Set the 'props' and 'children' properties to the 'props' and 'children' arrays respectively.\n  // Set the 'dom' property of the 'Vnode' instance to the DOM node.\n  let vnode = new Vnode(dom.tagName.toLowerCase(), props, children);\n  vnode.dom = dom;\n  return vnode as VnodeWithDom;\n}\n\n// This function takes in an HTML string and creates a virtual node representation of it\n// using the `domToVnode` function. It does this by creating a new `div` element, setting\n// its `innerHTML` to the provided HTML string, and then using `map` to iterate over the\n// `childNodes` of the `div` element, passing each one to `domToVnode` to create a virtual\n// node representation of it. The resulting array of virtual nodes is then returned.\nexport function trust(htmlString: string) {\n  let div = createDomElement(\"div\");\n  div.innerHTML = htmlString.trim();\n\n  return [].map.call(div.childNodes, (item) => domToVnode(item));\n}\n\n/* ========================================================================== */\n/* Main Component implementation                                              */\n/* ========================================================================== */\n\n// These variables are used to store the main component, the main virtual node, and whether\n// the main component is currently mounted.\nlet mainComponent: VnodeComponentInterface | null = null;\nlet mainVnode: VnodeWithDom | null = null;\nlet isMounted = false;\n\n// This object is used to store the current virtual node and component being rendered.\nexport const current: Current = {\n  vnode: null,\n  oldVnode: null,\n  component: null,\n  event: null\n};\n\n/* Reserved props ----------------------------------------------------------- */\n// This object is used to store the names of reserved props, which are props that are reserved\n// for special purposes and should not be used as regular component props.\nexport const reservedProps: Record<string, true> = {\n  key: true,\n  state: true,\n  \"v-keep\": true,\n\n  // Built in directives\n  \"v-if\": true,\n  \"v-unless\": true,\n  \"v-for\": true,\n  \"v-show\": true,\n  \"v-class\": true,\n  \"v-html\": true,\n  \"v-model\": true,\n  \"v-create\": true,\n  \"v-update\": true,\n  \"v-cleanup\": true\n};\n\n/* Mounting, Updating, Cleanup and Unmounting ------------------------------- */\n// These sets are used to store callbacks for various lifecycle events: mounting, updating,\n// cleaning up, and unmounting.\nconst onCleanupSet: Set<Function> = new Set();\nconst onMountSet: Set<Function> = new Set();\nconst onUpdateSet: Set<Function> = new Set();\nconst onUnmountSet: Set<Function> = new Set();\n\n// These functions allow users to register callbacks for the corresponding lifecycle events.\nexport function onMount(callback: Function) {\n  if (!isMounted) {\n    onMountSet.add(callback);\n  }\n}\n\nexport function onUpdate(callback: Function) {\n  onUpdateSet.add(callback);\n}\n\nexport function onCleanup(callback: Function) {\n  onCleanupSet.add(callback);\n}\n\nexport function onUnmount(callback: Function) {\n  if (!isMounted) {\n    onUnmountSet.add(callback);\n  }\n}\n\n// This function is used to call all the callbacks in a given set.\nfunction callSet(set: Set<Function>) {\n  for (let callback of set) {\n    callback();\n  }\n\n  set.clear();\n}\n\n/* Event listener ----------------------------------------------------------- */\n\n// This object stores the names of event listeners that have been added\nconst eventListenerNames: Record<string, true> = {};\n\n// This function is called when an event occurs\nfunction eventListener(e: Event) {\n  // Set the current event to the event that occurred so that it can be prevented if necessary\n  current.event = e;\n\n  // Convert the target of the event to a DOM element\n  let dom = e.target as DomElement;\n\n  // Create the name of the event listener by adding \"v-on\" to the event type\n  let name = `v-on${e.type}`;\n\n  // Keep going up the DOM tree until we find an element with an event listener\n  // matching the event type\n  while (dom) {\n    if (dom[name]) {\n      // Call the event listener function\n      dom[name](e, dom);\n\n      // If the default action of the event hasn't been prevented, update the DOM\n      if (!e.defaultPrevented) {\n        update();\n      }\n      return;\n    }\n    dom = dom.parentNode as DomElement;\n  }\n\n  current.event = null;\n}\n\n/* Directives --------------------------------------------------------------- */\n\n// This function creates a directive that hides an element based on a condition\nlet hideDirective = (test: boolean) => (bool: boolean, vnode: VnodeInterface, oldnode?: VnodeInterface) => {\n  // If test is true, use the value of bool. Otherwise, use the opposite of bool.\n  let value = test ? bool : !bool;\n\n  // If the value is true, hide the element by replacing it with a text node\n  if (value) {\n    let newdom = document.createTextNode(\"\");\n    if (oldnode && oldnode.dom && oldnode.dom.parentNode) {\n      oldnode.dom.parentNode.replaceChild(newdom, oldnode.dom);\n    }\n    vnode.tag = \"#text\";\n    vnode.children = [];\n    vnode.props = {};\n    vnode.dom = newdom as unknown as DomElement;\n    return false;\n  }\n};\n\n// This object stores all the available directives\nexport const directives: Directives = {\n  // The \"v-if\" directive hides an element if the given condition is false\n  \"v-if\": hideDirective(false),\n\n  // The \"v-unless\" directive hides an element if the given condition is true\n  \"v-unless\": hideDirective(true),\n\n  // The \"v-for\" directive creates a loop and applies a callback function to each item in the loop\n  \"v-for\": (set: unknown[], vnode: VnodeWithDom) => {\n    let newChildren: VnodeInterface[] = [];\n    let callback = vnode.children[0];\n    for (let i = 0, l = set.length; i < l; i++) {\n      newChildren.push(callback(set[i], i));\n    }\n    vnode.children = newChildren;\n  },\n\n  // The \"v-show\" directive shows or hides an element by setting the \"display\" style property\n  \"v-show\": (bool: boolean, vnode: VnodeWithDom) => {\n    (\n      vnode.dom as unknown as {\n        style: { display: string };\n      }\n    ).style.display = bool ? \"\" : \"none\";\n  },\n\n  // The \"v-class\" directive adds or removes class names from an element based on a condition\n  \"v-class\": (classes: { [x: string]: boolean }, vnode: VnodeWithDom) => {\n    // Loop through all the class names in the classes object\n    for (let name in classes) {\n      // Add or remove the class name from the element's class list based on the value in the classes object\n      (vnode.dom as DomElement).classList.toggle(name, classes[name]);\n    }\n  },\n\n  // The \"v-html\" directive sets the inner HTML of an element to the given HTML string\n  \"v-html\": (html: string, vnode: VnodeWithDom) => {\n    // Set the children of the vnode to a trusted version of the HTML string\n    vnode.children = [trust(html)];\n  },\n\n  // The \"v-model\" directive binds the value of an input element to a model property\n  \"v-model\": ([model, property, event]: any[], vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => {\n    let value;\n    // This function updates the model property when the input element's value changes\n    let handler = (e: Event) => (model[property] = (e.target as DomElement & Record<string, any>).value);\n    if (vnode.tag === \"input\") {\n      // If the element is an input, use the \"input\" event by default\n      event = event || \"oninput\";\n      // Depending on the type of input element, use a different handler function\n      switch (vnode.props.type) {\n        case \"checkbox\": {\n          if (Array.isArray(model[property])) {\n            // If the model property is an array, add or remove the value from the array when the checkbox is checked or unchecked\n            handler = (e: Event) => {\n              let val = (e.target as DomElement & Record<string, any>).value;\n              let idx = model[property].indexOf(val);\n              if (idx === -1) {\n                model[property].push(val);\n              } else {\n                model[property].splice(idx, 1);\n              }\n            };\n            // If the value is in the array, set the checkbox to be checked\n            value = model[property].indexOf(vnode.dom.value) !== -1;\n          } else if (\"value\" in vnode.props) {\n            // If the input element has a \"value\" attribute, use it to determine the checked state\n            handler = () => {\n              if (model[property] === vnode.props.value) {\n                model[property] = null;\n              } else {\n                model[property] = vnode.props.value;\n              }\n            };\n            value = model[property] === vnode.props.value;\n          } else {\n            // If there is no \"value\" attribute, use a boolean value for the model property\n            handler = () => (model[property] = !model[property]);\n            value = model[property];\n          }\n          // Set the \"checked\" attribute on the input element\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"checked\", value, vnode);\n          break;\n        }\n        case \"radio\": {\n          // If the element is a radio button, set the \"checked\" attribute based on the value of the model property\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"checked\", model[property] === vnode.dom.value, vnode);\n          break;\n        }\n        default: {\n          // For all other input types, set the \"value\" attribute based on the value of the model property\n          // eslint-disable-next-line no-use-before-define\n          sharedSetAttribute(\"value\", model[property], vnode);\n        }\n      }\n    } else if (vnode.tag === \"select\") {\n      // If the element is a select element, use the \"click\" event by default\n      event = event || \"onclick\";\n      if (vnode.props.multiple) {\n        // If the select element allows multiple selections, update the model property with an array of selected values\n        handler = (e: Event & Record<string, any>) => {\n          let val = (e.target as DomElement & Record<string, any>).value;\n          if (e.ctrlKey) {\n            // If the Ctrl key is pressed, add or remove the value from the array\n            let idx = model[property].indexOf(val);\n            if (idx === -1) {\n              model[property].push(val);\n            } else {\n              model[property].splice(idx, 1);\n            }\n          } else {\n            // If the Ctrl key is not pressed, set the model property to an array with the selected value\n            model[property].splice(0, model[property].length);\n            model[property].push(val);\n          }\n        };\n        // Set the \"selected\" attribute on the options based on whether they are in the model property array\n        vnode.children.forEach((child: VnodeInterface) => {\n          if (child.tag === \"option\") {\n            let value = \"value\" in child.props ? child.props.value : child.children.join(\"\").trim();\n            child.props.selected = model[property].indexOf(value) !== -1;\n          }\n        });\n      } else {\n        // If the select element does not allow multiple selections, set the \"selected\" attribute on the options based on the value of the model property\n        vnode.children.forEach((child: VnodeInterface) => {\n          if (child.tag === \"option\") {\n            let value = \"value\" in child.props ? child.props.value : child.children.join(\"\").trim();\n            child.props.selected = value === model[property];\n          }\n        });\n      }\n    } else if (vnode.tag === \"textarea\") {\n      // If the element is a textarea, use the \"input\" event by default\n      event = event || \"oninput\";\n      // Set the textarea's content to the value of the model property\n      vnode.children = [model[property]];\n    }\n\n    // We assume that the prev handler if any will not be changed by the user across patchs\n    let prevHandler = vnode.props[event];\n\n    // Set the event handler on the element\n    // eslint-disable-next-line no-use-before-define\n    sharedSetAttribute(\n      event,\n      (e: Event) => {\n        handler(e);\n\n        // If the previous handler is defined, call it after the model has been updated\n        if (prevHandler) {\n          prevHandler(e);\n        }\n      },\n      vnode,\n      oldVnode\n    );\n  },\n\n  // The \"v-create\" directive is called when a new virtual node is created.\n  // The provided callback function is called with the new virtual node as an argument.\n  // This directive is only called once per virtual node, when it is first created.\n  // eslint-disable-next-line no-unused-vars\n  \"v-create\": (callback: (vnode: VnodeWithDom) => void, vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => {\n    // If this is not an update, call the callback function with the new virtual node\n    if (!oldVnode) {\n      let cleanup = callback(vnode);\n\n      // If the callback function returns a function, call it when the update is gonna be cleaned up\n      if (typeof cleanup === \"function\") {\n        onCleanup(cleanup);\n      }\n    }\n  },\n\n  // The \"v-update\" directive is called when an existing virtual node is updated.\n  // The provided callback function is called with the new and old virtual nodes as arguments.\n  // This directive is only called once per virtual node update.\n  \"v-update\": (\n    // eslint-disable-next-line no-unused-vars\n    callback: (vnode: VnodeWithDom, oldVnode: VnodeWithDom) => void,\n    vnode: VnodeWithDom,\n    oldVnode?: VnodeWithDom\n  ) => {\n    // If this is an update, call the callback function with the new and old virtual nodes\n    if (oldVnode) {\n      let cleanup = callback(vnode, oldVnode);\n\n      // If the callback function returns a function, call it when the update is gonna be cleaned up\n      if (typeof cleanup === \"function\") {\n        onCleanup(cleanup);\n      }\n    }\n  },\n\n  // The \"v-cleanup\" directive is called when the update is cleaned up.\n  // The provided callback function is called with the old virtual node as an argument.\n  // This directive is only called once per virtual node, when the update is cleaned up.\n  \"v-cleanup\": (\n    // eslint-disable-next-line no-unused-vars\n    callback: (vnode: VnodeWithDom, oldVnode?: VnodeWithDom) => void,\n    vnode: VnodeWithDom,\n    oldVnode?: VnodeWithDom\n  ) => {\n    // Add the callback function to the list of cleanup functions to be called when the update is cleaned up\n    onCleanup(() => callback(vnode, oldVnode));\n  }\n};\n// Add a directive to the global directives object, with the key being the name\n// preceded by \"v-\". Also add the name to the global reservedProps object.\nexport function directive(name: string, directive: Directive) {\n  let directiveName = `v-${name}`;\n  directives[directiveName] = directive;\n  reservedProps[directiveName] = true;\n}\n\n// Set an attribute on a virtual DOM node and update the actual DOM element.\n// If the attribute value is a function, add an event listener for the attribute\n// name to the DOM element represented by mainVnode.\n// If oldVnode is provided, compare the new attribute value to the old value\n// and only update the attribute if the values are different.\nfunction sharedSetAttribute(name: string, value: any, newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void | boolean {\n  // If the attribute value is a function, add an event listener for the attribute\n  // name to the DOM element represented by mainVnode.\n  if (typeof value === \"function\") {\n    // Only add the event listener if it hasn't been added yet.\n    if (name in eventListenerNames === false) {\n      (mainVnode as VnodeWithDom).dom.addEventListener(name.slice(2), eventListener);\n      eventListenerNames[name] = true;\n    }\n    newVnode.dom[`v-${name}`] = value;\n    return;\n  }\n\n  // If the attribute is present on the DOM element and newVnode is not an SVG,\n  // update the attribute if the value has changed.\n  if (name in newVnode.dom && newVnode.isSVG === false) {\n    // eslint-disable-next-line eqeqeq\n    if (newVnode.dom[name] != value) {\n      newVnode.dom[name] = value;\n    }\n    return;\n  }\n\n  // If oldVnode is not provided or the attribute value has changed, update the\n  // attribute on the DOM element.\n  if (!oldVnode || value !== oldVnode.props[name]) {\n    if (value === false) {\n      newVnode.dom.removeAttribute(name);\n    } else {\n      newVnode.dom.setAttribute(name, value);\n    }\n  }\n}\n\n// Set an attribute on a virtual DOM node and update the actual DOM element.\n// Skip the attribute if it is in the reservedProps object.\nexport function setAttribute(name: string, value: any, newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  if (name in reservedProps) {\n    return;\n  }\n  newVnode.props[name] = value;\n  sharedSetAttribute(name, value, newVnode as VnodeWithDom, oldVnode);\n}\n\n// Update the attributes on a virtual DOM node. If oldVnode is provided, remove\n// attributes from the DOM element that are not present in newVnode.props but are\n// present in oldVnode.props. Then, iterate over the attributes in newVnode.props\n// and update the DOM element with the attributes using the sharedSetAttribute\n// function. If an attribute is in the reservedProps object and has a corresponding\n// directive in the directives object, call the directive with the attribute value\n// and the two virtual DOM nodes as arguments. If the directive returns false, exit\n// the loop.\nexport function updateAttributes(newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  // If oldVnode is provided, remove attributes from the DOM element that are not\n  // present in newVnode.props but are present in oldVnode.props.\n  if (oldVnode) {\n    for (let name in oldVnode.props) {\n      if (name in newVnode.props === false && name in eventListenerNames === false && name in reservedProps === false) {\n        if (name in newVnode.dom && newVnode.isSVG === false) {\n          newVnode.dom[name] = null;\n        } else {\n          newVnode.dom.removeAttribute(name);\n        }\n      }\n    }\n  }\n\n  // Iterate over the attributes in newVnode.props and update the DOM element with\n  // the attributes using the sharedSetAttribute function.\n  for (let name in newVnode.props) {\n    if (name in reservedProps) {\n      // If there is a directive for the attribute, call it with the attribute value\n      // and the two virtual DOM nodes as arguments. If the directive returns false,\n      // exit the loop.\n      if (name in directives && directives[name](newVnode.props[name], newVnode, oldVnode) === false) {\n        break;\n      }\n      continue;\n    }\n    sharedSetAttribute(name, newVnode.props[name], newVnode, oldVnode);\n  }\n}\n\n/* patch ------------------------------------------------------------------- */\n\n// Patch a DOM node with a new VNode tree\nexport function patch(newVnode: VnodeWithDom, oldVnode?: VnodeWithDom): void {\n  // If the new tree has no children, set the text content of the parent DOM element to an empty string\n  if (newVnode.children.length === 0) {\n    newVnode.dom.textContent = \"\";\n    return;\n  }\n\n  // Get the children of the new and old virtual DOM nodes\n  let newTree = newVnode.children;\n  let oldTree = oldVnode?.children || [];\n  // Get the length of the old tree\n  let oldTreeLength = oldTree.length;\n\n  // If the old tree has children and the first child of the new tree is a VNode with a \"key\"\n  // attribute and the first child of the old tree is a VNode with a \"key\" attribute, update\n  // the DOM element in place by comparing the keys of the nodes in the trees.\n  if (oldTreeLength && newTree[0] instanceof Vnode && \"key\" in newTree[0].props && \"key\" in oldTree[0].props) {\n    // Get the lengths of the new and old trees\n    let newTreeLength = newTree.length;\n\n    // Create an object that maps keys to indices in the old tree\n    let oldKeyedList: Record<string, number> = {};\n    for (let i = 0; i < oldTreeLength; i++) {\n      oldKeyedList[oldTree[i].props.key] = i;\n    }\n\n    // Create an object that maps keys to indices in the new tree\n    let newKeyedList: Record<string, number> = {};\n    for (let i = 0; i < newTreeLength; i++) {\n      newKeyedList[newTree[i].props.key] = i;\n    }\n\n    // Iterate over the new tree\n    for (let i = 0; i < newTreeLength; i++) {\n      // Get the current new child and the corresponding old child\n      let newChild = newTree[i];\n      let oldChild = oldTree[oldKeyedList[newChild.props.key]];\n      // Initialize a flag to determine whether to patch the child\n      let shouldPatch = true;\n\n      // If the old child exists, update the DOM element of the new child to match the old child's DOM element\n      if (oldChild) {\n        newChild.dom = oldChild.dom;\n        // If the new and old children have the same \"v-keep\" attribute value, update the children of the new child to match the old child's children\n        if (\"v-keep\" in newChild.props && newChild.props[\"v-keep\"] === oldChild.props[\"v-keep\"]) {\n          newChild.children = oldChild.children;\n          // Set the shouldPatch flag to false\n          shouldPatch = false;\n        } else {\n          updateAttributes(newChild, oldChild);\n        }\n\n        // If the old child does not exist, create a new DOM element for the new child and update its attributes\n      } else {\n        newChild.dom = createDomElement(newChild.tag, newChild.isSVG);\n        updateAttributes(newChild);\n      }\n\n      // If the new child's DOM element is not the i-th child of the parent DOM element, insert it\n      if (!newVnode.dom.childNodes[i]) {\n        newVnode.dom.appendChild(newChild.dom);\n\n        // If the new child's DOM element is not the same as the i-th child of the parent DOM element, replace the i-th child with the new child's DOM element\n      } else if (newVnode.dom.childNodes[i] !== newChild.dom) {\n        newVnode.dom.replaceChild(newChild.dom, newVnode.dom.childNodes[i]);\n      }\n\n      // If the shouldPatch flag is true, recursively call the patch function on the new child, passing in the old child as the second argument\n      shouldPatch && patch(newChild, oldChild);\n    }\n\n    // For the rest of the children, we should remove them from the DOM\n    for (let i = newTreeLength; i < oldTreeLength; i++) {\n      // If the i-th child of the old tree does not have a corresponding key in the new tree, remove its DOM element from the parent DOM element\n      if (!newKeyedList[oldTree[i].props.key]) {\n        oldTree[i].dom.parentNode && oldTree[i].dom.parentNode.removeChild(oldTree[i].dom);\n      }\n    }\n    return;\n  }\n\n  // If the new tree has no children, set the text content of the parent DOM element to an empty string\n  if (newTree.length === 0) {\n    newVnode.dom.textContent = \"\";\n    return;\n  }\n\n  // Set the global current object to the new and old virtual DOM nodes\n  current.vnode = newVnode;\n  current.oldVnode = oldVnode;\n\n  // Flatten the new tree\n  // Take into account that is necessary to flatten the tree before the patch process\n  // to let the hooks and signals work properly\n  for (let i = 0; i < newTree.length; i++) {\n    let newChild = newTree[i];\n\n    // If the new child is a Vnode and is not a text node\n    if (newChild instanceof Vnode) {\n      // If the tag of the new child is not a string, it is a component\n      if (typeof newChild.tag !== \"string\") {\n        // Set the current component to the tag of the new child\n        current.component = newChild.tag;\n        // Replace the new child with the result of calling its view or bind method, passing in the props and children as arguments\n        newTree.splice(\n          i--,\n          1,\n          (\"view\" in newChild.tag ? newChild.tag.view.bind(newChild.tag) : newChild.tag.bind(newChild.tag))(\n            newChild.props,\n            ...newChild.children\n          )\n        );\n      }\n\n      continue;\n    }\n\n    // If the new child is an array, flatten it and continue the loop\n    if (Array.isArray(newChild)) {\n      newTree.splice(i--, 1, ...newChild);\n      continue;\n    }\n\n    // If the new child is null or undefined, remove it from the new tree and continue the loop\n    if (newChild === null || newChild === undefined) {\n      newTree.splice(i--, 1);\n      continue;\n    }\n\n    // If the new child is a Vnode, set the text of the Vnode to the text content of its dom property\n    newTree[i] = new Vnode(textTag, {}, [newChild]);\n  }\n\n  // Patch the the old tree\n  for (let i = 0; i < newTree.length; i++) {\n    let newChild = newTree[i];\n\n    if (newChild.tag === textTag) {\n      // If no old child exists at the same index\n      if (i >= oldTreeLength) {\n        // Create a new text node for the new child\n        newChild.dom = document.createTextNode(newChild.children[0]);\n        // Append the new text node to the dom\n        newVnode.dom.appendChild(newChild.dom);\n        continue;\n      }\n\n      // If there is an old child at the same index\n      let oldChild = oldTree[i];\n\n      // If the old child is not a text node\n      if (oldChild.tag !== textTag) {\n        // Create a new text node for the new child\n        newChild.dom = document.createTextNode(newChild.children[0]);\n        // Replace the old child in the dom with the new text node\n        newVnode.dom.replaceChild(newChild.dom, oldChild.dom);\n        continue;\n      }\n\n      // If the old child is a text node\n      // Set the dom property of the text Vnode to the dom property of the old child\n      newChild.dom = oldChild.dom;\n      // If the text content of the old child is different from the new child, update the text content of the old child\n      // eslint-disable-next-line eqeqeq\n      if (newChild.children[0] != oldChild.dom.textContent) {\n        oldChild.dom.textContent = newChild.children[0];\n      }\n      continue;\n    }\n\n    // If the new child is not a text node\n    // Set the isSVG flag for the new child if it is an SVG element or if the parent is an SVG element\n    newChild.isSVG = newVnode.isSVG || newChild.tag === \"svg\";\n\n    // If there is no old child at the same index\n    if (i >= oldTreeLength) {\n      // Create a new dom element for the new child\n      newChild.dom = createDomElement(newChild.tag as string, newChild.isSVG);\n      // Update the attributes of the new child\n      updateAttributes(newChild as VnodeWithDom);\n      // Append the new child to the dom\n      newVnode.dom.appendChild(newChild.dom);\n      // Recursively patch the new child\n      patch(newChild as VnodeWithDom);\n      continue;\n    }\n\n    // If there is an old child at the same index\n    let oldChild = oldTree[i];\n\n    // If the tag of the new child is different from the tag of the old child\n    if (newChild.tag !== oldChild.tag) {\n      // Create a new dom element for the new child\n      newChild.dom = createDomElement(newChild.tag as string, newChild.isSVG);\n      // Update the attributes of the new child\n      updateAttributes(newChild as VnodeWithDom);\n      // Replace the old child in the dom with the new child\n      newVnode.dom.replaceChild(newChild.dom, oldChild.dom);\n      // Recursively patch the new child\n      patch(newChild as VnodeWithDom);\n      continue;\n    }\n\n    // If the tag of the new child is the same as the tag of the old child\n    // Set the dom property of the new child to the dom property of the old child\n    newChild.dom = oldChild.dom;\n    // If the v-keep prop is the same for both the new and old child, set the children of the new child to the children of the old child\n    if (\"v-keep\" in newChild.props && newChild.props[\"v-keep\"] === oldChild.props[\"v-keep\"]) {\n      newChild.children = oldChild.children;\n      continue;\n    }\n\n    // Update the attributes of the new child based on the old child\n    updateAttributes(newChild as VnodeWithDom, oldChild);\n    // Recursively patch the new and old children\n    patch(newChild as VnodeWithDom, oldChild);\n  }\n\n  // Remove any old children that are no longer present in the new tree\n  for (let i = newTree.length; i < oldTreeLength; i++) {\n    newVnode.dom.removeChild(oldTree[i].dom);\n  }\n}\n\n// Update the main Vnode\nexport function update(): void | string {\n  // If the main Vnode exists\n  if (mainVnode) {\n    // Call any cleanup functions that are registered with the onCleanupSet set\n    callSet(onCleanupSet);\n    // Store a reference to the old main Vnode\n    let oldMainVnode = mainVnode;\n    // Create a new main Vnode with the main component as its only child\n    mainVnode = new Vnode(oldMainVnode.tag, oldMainVnode.props, [mainComponent]) as VnodeWithDom;\n    mainVnode.dom = oldMainVnode.dom;\n    mainVnode.isSVG = oldMainVnode.isSVG;\n\n    // Recursively patch the new and old main Vnodes\n    patch(mainVnode, oldMainVnode);\n\n    // Call any update or mount functions that are registered with the onUpdateSet or onMountSet set\n    callSet(isMounted ? onUpdateSet : onMountSet);\n\n    // Set the isMounted flag to true\n    isMounted = true;\n\n    // Reset the current vnode, oldVnode, and component properties\n    current.vnode = null;\n    current.oldVnode = null;\n    current.component = null;\n\n    // If the code is running in a Node.js environment, return the inner HTML of the main Vnode's dom element\n    if (isNodeJs) {\n      return mainVnode.dom.innerHTML;\n    }\n  }\n}\n\n// Update custom Vnode\n// It is assumed that a first mount has already occurred, so,\n// the oldVnode is not null and the dom property of the oldVnode is not null\n// You need to set the dom property of the newVnode to the dom property of the oldVnode\n// The same with the isSVG property\n// Prefer this function over patch to allow for cleanup, onUpdate and onMount sets to be called\nexport function updateVnode(vnode: VnodeWithDom, oldVnode: VnodeWithDom): string | void {\n  // Call any cleanup functions that are registered with the onCleanupSet set\n  callSet(onCleanupSet);\n\n  // Recursively patch the new and old main Vnodes\n  patch(vnode, oldVnode);\n\n  // Set the oldVnode's tag, props, children, dom, and isSVG properties to the newVnode's tag, props, children, dom, and isSVG properties\n  // This is necessary to allow for the oldVnode to be used as the newVnode in the next update with the normal update function\n  oldVnode.tag = vnode.tag;\n  oldVnode.props = { ...vnode.props };\n  oldVnode.children = [...vnode.children];\n  oldVnode.dom = vnode.dom;\n  oldVnode.isSVG = vnode.isSVG;\n\n  // Call any update or mount functions that are registered with the onUpdateSet or onMountSet set\n  callSet(isMounted ? onUpdateSet : onMountSet);\n\n  // Set the isMounted flag to true\n  isMounted = true;\n\n  // Reset the current vnode, oldVnode, and component properties\n  current.vnode = null;\n  current.oldVnode = null;\n  current.component = null;\n\n  if (isNodeJs) {\n    return vnode.dom.innerHTML;\n  }\n}\n\n// Unmount the main Vnode\nexport function unmount() {\n  // If the main Vnode exists\n  if (mainVnode) {\n    // Set the main component to a null Vnode\n    mainComponent = new Vnode(() => null, {}, []) as VnodeComponentInterface;\n    // Update the main Vnode\n    let result = update();\n    // Call any unmount functions that are registered with the onUnmountSet set\n    callSet(onUnmountSet);\n\n    // Remove any event listeners that were added to the main Vnode's dom element\n    for (let name in eventListenerNames) {\n      mainVnode.dom.removeEventListener(name.slice(2).toLowerCase(), eventListener);\n      Reflect.deleteProperty(eventListenerNames, name);\n    }\n\n    // Reset the main component and main Vnode\n    mainComponent = null;\n    mainVnode = null;\n    // Set the isMounted flag to false\n    isMounted = false;\n    // Reset the current vnode, oldVnode, and component properties\n    current.vnode = null;\n    current.oldVnode = null;\n    current.component = null;\n    // Return the result of updating the main Vnode\n    return result;\n  }\n}\n// This function takes in a DOM element or a DOM element selector and a component to be mounted on it.\nexport function mount(dom: string | DomElement, component: any) {\n  // Check if the 'dom' argument is a string. If it is, select the first element that matches the given selector.\n  // Otherwise, use the 'dom' argument as the container.\n  let container =\n    typeof dom === \"string\"\n      ? isNodeJs\n        ? createDomElement(dom, dom === \"svg\")\n        : document.querySelectorAll(dom)[0]\n      : dom;\n\n  // Check if the 'component' argument is a Vnode component or a regular component.\n  // If it's a regular component, create a new Vnode component using the 'component' argument as the tag.\n  // If it's not a component at all, create a new Vnode component with the 'component' argument as the rendering function.\n  let vnodeComponent = isVnodeComponent(component)\n    ? component\n    : isComponent(component)\n    ? new Vnode(component, {}, [])\n    : new Vnode(() => component, {}, []);\n\n  // If a main component already exists and it's not the same as the current 'vnodeComponent', unmount it.\n  if (mainComponent && mainComponent.tag !== vnodeComponent.tag) {\n    unmount();\n  }\n\n  // Set the 'vnodeComponent' as the main component.\n  mainComponent = vnodeComponent as VnodeComponentInterface;\n  // Convert the container element to a Vnode.\n  mainVnode = domToVnode(container);\n  // Update the DOM with the new component.\n  return update();\n}\n\n// This is a utility function for creating Vnode objects.\n// It takes in a tag or component, and optional props and children arguments.\nexport const v: V = (tagOrComponent, props = {}, ...children) => {\n  // Return a new Vnode object using the given arguments.\n  return new Vnode(tagOrComponent, props || {}, children);\n};\n\n// This utility function creates a fragment Vnode.\n// It takes in a placeholder and the children arguments, returns only the children.\nv.fragment = (_: VnodeProperties, ...children: Children) => children;\n"],
  "mappings": "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",
  "names": ["Vnode", "vnode", "value", "directive", "oldChild"]
}
