{
  "version": 3,
  "sources": ["../../lib/signal/index.ts"],
  "sourcesContent": ["import { VnodeWithDom, current, onUnmount, updateVnode, v } from \"valyrian.js\";\n\ninterface GetterInterface {\n  (): any;\n}\n\ninterface SetterInterface {\n  (value: any): void;\n}\n\ninterface SubscribeInterface {\n  (callback: Function): void;\n}\n\ninterface SubscriptionsInterface extends Array<Function> {}\n\nexport interface SignalInterface extends Array<any> {\n  0: GetterInterface;\n  1: SetterInterface;\n  2: SubscribeInterface;\n  3: SubscriptionsInterface;\n}\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function Signal(initialValue: any): SignalInterface {\n  // Create a copy of the current context object\n  const { vnode, component } = { ...current };\n\n  // Check if the context object has a vnode property\n  if (vnode && component) {\n    // Is first call\n    if (!vnode.components) {\n      // Set the components property to an empty array\n      vnode.components = [];\n    }\n\n    // Check if the components array of the vnode object does not contain the component object\n    if (vnode.components.indexOf(component) === -1) {\n      // Set the calls property to -1\n      vnode.signal_calls = -1;\n      // Add the component to the components array\n      vnode.components.push(component);\n\n      // Check if the component object has a signals property\n      if (!component.signals) {\n        // Set the signals property of the component object to an empty array\n        component.signals = [];\n        // Add a function to the cleanup stack that removes the signals property from the component object\n        onUnmount(() => Reflect.deleteProperty(component, \"signals\"));\n      }\n    }\n\n    // Assign the signal variable to the signal stored at the index of the vnode object's calls property in the vnode's signals array\n    let signal: SignalInterface = component.signals[++vnode.signal_calls];\n\n    // If a signal has already been assigned to the signal variable, return it\n    if (signal) {\n      // Remove all subscriptions because we come from a new render\n      signal[3].length = 0;\n\n      // Return the signal\n      return signal;\n    }\n  }\n\n  // Declare a variable to store the current value of the Signal\n  let value = initialValue;\n\n  // Create an array to store functions that have subscribed to changes to the Signal's value\n  const subscriptions: SubscriptionsInterface = [];\n\n  // Define a function that allows other parts of the code to subscribe to changes to the Signal's value\n  const subscribe = (callback: Function) => {\n    // Add the callback function to the subscriptions array if it is not already in the array\n    if (subscriptions.indexOf(callback) === -1) {\n      subscriptions.push(callback);\n    }\n  };\n\n  // Set the vnodes to update when the Signal's value changes\n  let vnodesToUpdate: Array<VnodeWithDom> = [];\n\n  // This is the function that will be called when the Signal's value changes\n  const updateVnodes = () => {\n    // Create a copy of the vnodesToUpdate array and filter out any duplicate vnodes\n    let vnodesToUpdateCopy = vnodesToUpdate.filter((vnode, index, self) => {\n      return self.findIndex((v) => v.dom === vnode.dom) === index;\n    });\n\n    // Loop through the vnodesToUpdate array\n    for (let i = 0, l = vnodesToUpdateCopy.length; i < l; i++) {\n      const vnode2 = vnodesToUpdateCopy[i];\n      // If it does, create a new vnode object based on the original vnode, its children, and its DOM and SVG properties\n      let newVnode = v(vnode2.tag, vnode2.props, ...vnode2.initialChildren) as VnodeWithDom;\n      newVnode.dom = vnode2.dom; // Set the new vnode object's DOM property to the old vnode object's DOM property\n      newVnode.isSVG = vnode2.isSVG; // Set the new vnode object's isSVG property to the old vnode object's isSVG property\n\n      // Update the vnode object\n      updateVnode(newVnode, vnode2);\n    }\n  };\n\n  // Define a function that returns the current value of the Signal\n  function get() {\n    // Get the current vnode from the context object\n    const { vnode: vnode2 } = current;\n\n    // If we have a current vnode, it means that a get function is being called from within a component\n    // so we subscribe the vnode to be updated when the Signal's value changes\n    if (vnode2 && vnodesToUpdate.indexOf(vnode2) === -1) {\n      // We set the initialChildren to a copy of the vnode's children array\n      // This is the case when the vnode is a component that has not been rendered yet and we need the initial children\n      // because they could have the components that are using the Signal\n      if (!vnode2.initialChildren) {\n        vnode2.initialChildren = [...vnode2.children];\n      }\n\n      // Add the vnode to the vnodesToUpdate array\n      vnodesToUpdate.push(vnode2);\n\n      // Subscribe the updateVnodes function to the Signal\n      subscribe(updateVnodes);\n    }\n\n    // Return the current value of the Signal\n    return value;\n  }\n\n  // Define a function that allows the value of the Signal to be updated and notifies any subscribed functions of the change\n  const set = (newValue: any) => {\n    // If we have a current event on going, prevent the default action\n    if (current.event) {\n      current.event.preventDefault();\n    }\n\n    // Just return if the new value is the same as the current value\n    if (newValue === value) {\n      return;\n    }\n\n    // Update the value of the Signal\n    value = newValue;\n\n    // Call each subscribed function with the new value of the Signal as an argument\n    for (let i = 0, l = subscriptions.length; i < l; i++) {\n      subscriptions[i](value);\n    }\n  };\n\n  // Assign the signal variable an array containing the get, set, and subscribe functions\n  let signal: SignalInterface = [get, set, subscribe, subscriptions];\n\n  // If the context object has a vnode property, add the signal to the vnode's signals array\n  // and add the subscriptions array to the vnode's subscriptions array\n  if (vnode && component) {\n    component.signals.push(signal);\n  }\n\n  // Return the signal\n  return signal;\n}\n"],
  "mappings": ";AAAA,SAAuB,SAAS,WAAW,aAAa,SAAS;AAwB1D,SAAS,OAAO,cAAoC;AAEzD,QAAM,EAAE,OAAO,UAAU,IAAI,EAAE,GAAG,QAAQ;AAG1C,MAAI,SAAS,WAAW;AAEtB,QAAI,CAAC,MAAM,YAAY;AAErB,YAAM,aAAa,CAAC;AAAA,IACtB;AAGA,QAAI,MAAM,WAAW,QAAQ,SAAS,MAAM,IAAI;AAE9C,YAAM,eAAe;AAErB,YAAM,WAAW,KAAK,SAAS;AAG/B,UAAI,CAAC,UAAU,SAAS;AAEtB,kBAAU,UAAU,CAAC;AAErB,kBAAU,MAAM,QAAQ,eAAe,WAAW,SAAS,CAAC;AAAA,MAC9D;AAAA,IACF;AAGA,QAAIA,UAA0B,UAAU,QAAQ,EAAE,MAAM,YAAY;AAGpE,QAAIA,SAAQ;AAEV,MAAAA,QAAO,CAAC,EAAE,SAAS;AAGnB,aAAOA;AAAA,IACT;AAAA,EACF;AAGA,MAAI,QAAQ;AAGZ,QAAM,gBAAwC,CAAC;AAG/C,QAAM,YAAY,CAAC,aAAuB;AAExC,QAAI,cAAc,QAAQ,QAAQ,MAAM,IAAI;AAC1C,oBAAc,KAAK,QAAQ;AAAA,IAC7B;AAAA,EACF;AAGA,MAAI,iBAAsC,CAAC;AAG3C,QAAM,eAAe,MAAM;AAEzB,QAAI,qBAAqB,eAAe,OAAO,CAACC,QAAO,OAAO,SAAS;AACrE,aAAO,KAAK,UAAU,CAACC,OAAMA,GAAE,QAAQD,OAAM,GAAG,MAAM;AAAA,IACxD,CAAC;AAGD,aAAS,IAAI,GAAG,IAAI,mBAAmB,QAAQ,IAAI,GAAG,KAAK;AACzD,YAAM,SAAS,mBAAmB,CAAC;AAEnC,UAAI,WAAW,EAAE,OAAO,KAAK,OAAO,OAAO,GAAG,OAAO,eAAe;AACpE,eAAS,MAAM,OAAO;AACtB,eAAS,QAAQ,OAAO;AAGxB,kBAAY,UAAU,MAAM;AAAA,IAC9B;AAAA,EACF;AAGA,WAAS,MAAM;AAEb,UAAM,EAAE,OAAO,OAAO,IAAI;AAI1B,QAAI,UAAU,eAAe,QAAQ,MAAM,MAAM,IAAI;AAInD,UAAI,CAAC,OAAO,iBAAiB;AAC3B,eAAO,kBAAkB,CAAC,GAAG,OAAO,QAAQ;AAAA,MAC9C;AAGA,qBAAe,KAAK,MAAM;AAG1B,gBAAU,YAAY;AAAA,IACxB;AAGA,WAAO;AAAA,EACT;AAGA,QAAM,MAAM,CAAC,aAAkB;AAE7B,QAAI,QAAQ,OAAO;AACjB,cAAQ,MAAM,eAAe;AAAA,IAC/B;AAGA,QAAI,aAAa,OAAO;AACtB;AAAA,IACF;AAGA,YAAQ;AAGR,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,IAAI,GAAG,KAAK;AACpD,oBAAc,CAAC,EAAE,KAAK;AAAA,IACxB;AAAA,EACF;AAGA,MAAI,SAA0B,CAAC,KAAK,KAAK,WAAW,aAAa;AAIjE,MAAI,SAAS,WAAW;AACtB,cAAU,QAAQ,KAAK,MAAM;AAAA,EAC/B;AAGA,SAAO;AACT;",
  "names": ["signal", "vnode", "v"]
}
