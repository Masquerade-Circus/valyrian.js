{
  "version": 3,
  "sources": ["../../lib/proxy-signal/index.ts"],
  "sourcesContent": ["import { update } from \"valyrian.js\";\n\n/* eslint-disable no-use-before-define */\ninterface Cleanup {\n  (): void;\n}\n\ninterface Subscription {\n  // eslint-disable-next-line no-unused-vars\n  (value: ProxySignal[\"value\"]): void | Cleanup;\n}\n\ninterface Subscriptions extends Map<Subscription, Cleanup> {}\n\ninterface Getter {\n  // eslint-disable-next-line no-unused-vars\n  (value: ProxySignal[\"value\"]): any;\n}\n\ninterface Getters {\n  [key: string | symbol]: Getter;\n}\n\ninterface ProxySignal {\n  // Works as a getter of the value\n  (): ProxySignal[\"value\"];\n  // Works as a subscription to the value\n  // eslint-disable-next-line no-unused-vars\n  (value: Subscription): ProxySignal;\n  // Works as a setter with a path and a handler\n  // eslint-disable-next-line no-unused-vars\n  (path: string, handler: (valueAtPathPosition: any) => any): ProxySignal[\"value\"];\n  // Works as a setter with a path and a value\n  // eslint-disable-next-line no-unused-vars\n  (path: string, value: any): ProxySignal[\"value\"];\n  // Works as a setter with a value\n  // eslint-disable-next-line no-unused-vars\n  (value: any): ProxySignal[\"value\"];\n  // Gets the current value of the signal.\n  value: any;\n  // Cleanup function to be called to remove all subscriptions.\n  cleanup: () => void;\n  // Creates a getter on the signal.\n  // eslint-disable-next-line no-unused-vars\n  getter: (name: string, handler: Getter) => any;\n  // To access the getters on the signal.\n  [key: string | number | symbol]: any;\n}\n\nfunction makeUnsubscribe(\n  subscriptions: Subscriptions,\n  computed: ProxySignal,\n  handler: Subscription,\n  cleanup?: Cleanup\n) {\n  if (typeof cleanup === \"function\") {\n    computed.cleanup = cleanup;\n  }\n  computed.unsubscribe = () => {\n    subscriptions.delete(handler);\n    computed?.cleanup();\n  };\n}\n\nfunction createSubscription(signal: ProxySignal, subscriptions: Subscriptions, handler: Subscription) {\n  if (subscriptions.has(handler) === false) {\n    // eslint-disable-next-line no-use-before-define\n    let computed = ProxySignal(() => handler(signal.value));\n    let cleanup = computed(); // Execute to register itself\n    makeUnsubscribe(subscriptions, computed, handler, cleanup);\n    subscriptions.set(handler, computed);\n  }\n\n  return subscriptions.get(handler);\n}\n\nlet updateTimeout: any;\nfunction delayedUpdate() {\n  clearTimeout(updateTimeout);\n  updateTimeout = setTimeout(update);\n}\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function ProxySignal(value: any): ProxySignal {\n  let subscriptions = new Map();\n  let getters: Getters = {};\n\n  let forceUpdate = false;\n\n  let signal: ProxySignal = new Proxy(\n    // eslint-disable-next-line no-unused-vars\n    function (valOrPath?: any | Subscription, handler?: (valueAtPathPosition: any) => any) {\n      // Works as a getter\n      if (typeof valOrPath === \"undefined\") {\n        return signal.value;\n      }\n\n      // Works as a subscription\n      if (typeof valOrPath === \"function\") {\n        return createSubscription(signal, subscriptions, valOrPath);\n      }\n\n      // Works as a setter with a path\n      if (typeof valOrPath === \"string\" && typeof handler !== \"undefined\") {\n        let parsed = valOrPath.split(\".\");\n        let result = signal.value;\n        let next;\n        while (parsed.length) {\n          next = parsed.shift() as string;\n          if (parsed.length > 0) {\n            if (typeof result[next] !== \"object\") {\n              result[next] = {};\n            }\n            result = result[next];\n          } else {\n            result[next] = typeof handler === \"function\" ? handler(result[next]) : handler;\n          }\n        }\n        forceUpdate = true;\n        signal.value = signal.value;\n        return signal.value;\n      }\n\n      // Works as a setter with a value\n      signal.value = valOrPath;\n      return signal.value;\n    } as ProxySignal,\n    {\n      set(state, prop, val) {\n        if (prop === \"value\" || prop === \"unsubscribe\" || prop === \"cleanup\") {\n          let old = state[prop];\n          state[prop] = val;\n          if (prop === \"value\" && (forceUpdate || val !== old)) {\n            forceUpdate = false;\n            for (let [handler, computed] of subscriptions) {\n              computed.cleanup();\n              let cleanup = handler(val);\n              makeUnsubscribe(subscriptions, computed, handler, cleanup);\n            }\n            delayedUpdate();\n          }\n          return true;\n        }\n        return false;\n      },\n      get(state, prop) {\n        if (prop === \"value\") {\n          return typeof state.value === \"function\" ? state.value() : state.value;\n        }\n\n        if (prop === \"cleanup\" || prop === \"unsubscribe\" || prop === \"getter\") {\n          return state[prop];\n        }\n\n        if (prop in getters) {\n          return getters[prop](state.value);\n        }\n      }\n    }\n  );\n\n  Object.defineProperties(signal, {\n    value: { value, writable: true, enumerable: true },\n    cleanup: {\n      value() {\n        // eslint-disable-next-line no-unused-vars\n        for (let [handler, computed] of subscriptions) {\n          computed.unsubscribe();\n        }\n      },\n      writable: true,\n      enumerable: true\n    },\n    getter: {\n      value(name: string, handler: Getter) {\n        if (name in getters) {\n          throw new Error(\"Named computed already exists.\");\n        }\n\n        getters[name] = handler;\n      },\n      enumerable: true\n    }\n  });\n\n  return signal;\n}\n"],
  "mappings": "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",
  "names": []
}
