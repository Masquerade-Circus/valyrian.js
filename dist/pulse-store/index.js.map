{
  "version": 3,
  "sources": ["../../lib/pulse-store/index.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\nimport { updateVnode, Vnode, VnodeWithDom, current } from \"valyrian.js\";\nimport { deepCloneUnfreeze, deepFreeze, hasChanged } from \"valyrian.js/utils\";\n\ntype State = Record<string, any>;\n\n// An action or pulse type definition\nexport type Pulse<StateType> = (state: StateType, ...args: any[]) => void | Promise<void>;\n\n// A collection of pulses\nexport type Pulses<StateType> = {\n  [key: string]: Pulse<StateType>;\n};\n\n// A proxy state\n// This is a state that is proxied to automatically subscribe to changes\n// And is used internally to update the vnode when the state changes\ntype ProxyState<StateType> = StateType & {\n  [key: string]: any;\n};\n\n// The effect stack\nconst effectStack: Function[] = [];\n\n// Creates the store\n// eslint-disable-next-line sonarjs/cognitive-complexity\nfunction createStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType | (() => StateType),\n  pulses: PulsesType,\n  immutable = false\n): () => [ProxyState<StateType>, PulsesType] {\n  const subscribers = new Set<Function>();\n  const vnodesToUpdate = new WeakSet<Vnode>();\n\n  // Initialize the localState for this store\n  const localState = (typeof initialState === \"function\" ? initialState() : initialState) || {};\n\n  function isMutable() {\n    if (immutable) {\n      throw new Error(\"You need to call a pulse to modify the state\");\n    }\n  }\n\n  // We create a proxy for the state\n  const proxyState = new Proxy(localState || {}, {\n    get: (state, prop: string) => {\n      const currentEffect = effectStack[effectStack.length - 1];\n      if (currentEffect && !subscribers.has(currentEffect)) {\n        subscribers.add(currentEffect);\n      }\n\n      const currentVnode = current.vnode as VnodeWithDom;\n      if (currentVnode && !vnodesToUpdate.has(currentVnode)) {\n        const subscription = () => {\n          if (!currentVnode.dom) {\n            subscribers.delete(subscription);\n            vnodesToUpdate.delete(currentVnode);\n            return;\n          }\n\n          updateVnode(currentVnode);\n        };\n\n        subscribers.add(subscription);\n        vnodesToUpdate.add(currentVnode);\n      }\n\n      return state[prop];\n    },\n    // If the user tries to set directly it will throw an error\n    set: (state, prop: string, value: any) => {\n      isMutable();\n      Reflect.set(state, prop, value);\n      return true;\n    },\n    // If the user tries to delete directly it will throw an error\n    deleteProperty: (state, prop: string) => {\n      isMutable();\n      Reflect.deleteProperty(state, prop);\n      return true;\n    }\n  });\n\n  function syncState(newState: StateType) {\n    for (const key in newState) {\n      localState[key] = immutable ? deepFreeze(newState[key]) : newState[key];\n    }\n\n    for (const key in localState) {\n      if (!(key in newState)) {\n        Reflect.deleteProperty(localState, key);\n      }\n    }\n  }\n\n  function setState(newState: StateType) {\n    if (!hasChanged(localState, newState)) {\n      return;\n    }\n\n    syncState(newState);\n\n    subscribers.forEach((subscriber) => subscriber());\n  }\n\n  function getPulseMethod(key: string) {\n    return (...args: any[]) => {\n      const currentState = deepCloneUnfreeze(localState);\n      const pulse = pulses[key](currentState, ...args);\n\n      if (pulse instanceof Promise) {\n        return pulse\n          .then(() => setState(currentState))\n          .catch((error) => {\n            console.error(\"Error in pulse:\", error);\n          });\n      }\n\n      setState(currentState);\n    };\n  }\n\n  const boundPulses: Record<string, Pulse<StateType>> = {};\n  for (const key in pulses) {\n    if (typeof pulses[key] !== \"function\") {\n      throw new Error(`Pulse '${key}' must be a function`);\n    }\n    boundPulses[key] = getPulseMethod(key);\n  }\n\n  const pulsesProxy = new Proxy(boundPulses, {\n    get: (pulses, prop: string) => {\n      if (!(prop in pulses)) {\n        throw new Error(`Pulse '${prop}' does not exist`);\n      }\n      return pulses[prop];\n    }\n  });\n\n  function usePulseStore(): [ProxyState<StateType>, PulsesType] {\n    return [proxyState, pulsesProxy as PulsesType];\n  }\n\n  syncState(localState);\n\n  return usePulseStore;\n}\n\n// Creates a pulse store with an immutable state by default\nexport function createPulseStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): () => [ProxyState<StateType>, PulsesType] {\n  return createStore(initialState, pulses, true);\n}\n\n// Creates a mutable store, useful for performance, but not recommended\nexport function createMutableStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): () => [ProxyState<StateType>, PulsesType] {\n  console.warn(\n    \"Warning: You are working with a mutable state. This can lead to unpredictable behavior. All state changes made outside of a pulse will not trigger a re-render.\"\n  );\n  return createStore(initialState, pulses, false);\n}\n\n// Creates an effect\nexport function createEffect(effect: Function) {\n  const runEffect = () => {\n    try {\n      effectStack.push(runEffect);\n      effect();\n    } finally {\n      effectStack.pop();\n    }\n  };\n\n  runEffect();\n}\n"],
  "mappings": "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",
  "names": ["pulses"]
}
