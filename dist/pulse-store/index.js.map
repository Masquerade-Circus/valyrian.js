{
  "version": 3,
  "sources": ["../../lib/pulse-store/index.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\nimport { updateVnode, VnodeWithDom, current, DomElement } from \"valyrian.js\";\nimport { deepCloneUnfreeze, deepFreeze, hasChanged } from \"valyrian.js/utils\";\n\ntype State = Record<string, any>;\n\nexport type Pulse<StateType, TReturn = unknown> = (state: StateType, ...args: any[]) => TReturn | Promise<TReturn>;\n\nexport type Pulses<StateType> = Record<string, Pulse<StateType, any>>;\n\ntype ProxyState<StateType> = StateType & {\n  [key: string]: any;\n};\n\nconst effectStack: Function[] = [];\n\ntype StorePulses<PulsesType extends Pulses<any>> = {\n  [K in keyof PulsesType]: PulsesType[K] extends (state: any, ...args: infer Args) => infer R\n    ? (...args: Args) => R\n    : never;\n};\n\n// Crea la tienda\nfunction createStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType | (() => StateType) | null,\n  pulses: PulsesType,\n  immutable = false\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  const subscribers = new Set<Function>();\n  const domWithVnodesToUpdate = new WeakSet<DomElement>();\n\n  const boundPulses: Record<string, Pulse<StateType, any>> = {};\n  for (const key in pulses) {\n    if (typeof pulses[key] !== \"function\") {\n      throw new Error(`Pulse '${key}' must be a function`);\n    }\n    if (key === \"state\") {\n      throw new Error(`A pulse cannot be named 'state'`);\n    }\n    boundPulses[key] = getPulseMethod(key);\n  }\n\n  const localState: StateType =\n    (typeof initialState === \"function\" ? initialState() : initialState) || ({} as StateType);\n\n  function isMutable() {\n    if (immutable) {\n      throw new Error(\"You need to call a pulse to modify the state\");\n    }\n  }\n\n  let currentState: StateType | null = null;\n  let pulseCallCount = 0;\n\n  const proxyState = new Proxy(localState, {\n    get: (state, prop: string) => {\n      // If there is a current state, return the value from it\n      // because we are inside a pulse\n      if (currentState) {\n        return currentState[prop];\n      }\n\n      const currentEffect = effectStack[effectStack.length - 1];\n      if (currentEffect && !subscribers.has(currentEffect)) {\n        subscribers.add(currentEffect);\n      }\n\n      const currentVnode = current.vnode as VnodeWithDom;\n      if (currentVnode && !domWithVnodesToUpdate.has(currentVnode.dom)) {\n        let hasParent = false;\n        let parent = currentVnode.dom.parentElement as DomElement;\n        while (parent) {\n          if (domWithVnodesToUpdate.has(parent)) {\n            hasParent = true;\n            break;\n          }\n          parent = parent.parentElement as DomElement;\n        }\n\n        if (hasParent) {\n          return state[prop];\n        }\n\n        const dom = currentVnode.dom;\n        const subscription = () => {\n          updateVnode(dom.vnode);\n          if (!dom.parentElement) {\n            subscribers.delete(subscription);\n            domWithVnodesToUpdate.delete(dom);\n          }\n        };\n\n        subscribers.add(subscription);\n        domWithVnodesToUpdate.add(dom);\n      }\n\n      return state[prop];\n    },\n    set: (state, prop: string, value: any) => {\n      isMutable();\n      Reflect.set(state, prop, value);\n      return true;\n    },\n    deleteProperty: (state, prop: string) => {\n      isMutable();\n      Reflect.deleteProperty(state, prop);\n      return true;\n    }\n  });\n\n  function syncState(newState: StateType) {\n    for (const key in newState) {\n      localState[key] = immutable ? deepFreeze(newState[key]) : newState[key];\n    }\n\n    for (const key in localState) {\n      if (!(key in newState)) {\n        Reflect.deleteProperty(localState, key);\n      }\n    }\n  }\n\n  let debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n  function debouncedUpdate() {\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout);\n    }\n\n    debounceTimeout = setTimeout(() => subscribers.forEach((subscriber) => subscriber()), 0);\n  }\n\n  function setState(newState: StateType) {\n    pulseCallCount--;\n\n    if (!hasChanged(localState, newState)) {\n      return;\n    }\n\n    if (pulseCallCount > 0) {\n      return;\n    }\n\n    syncState(newState);\n    currentState = null;\n    debouncedUpdate();\n  }\n\n  function getPulseMethod(key: string) {\n    return (...args: any[]) => {\n      pulseCallCount++;\n\n      if (currentState === null) {\n        currentState = deepCloneUnfreeze(localState);\n      }\n\n      try {\n        const pulseResult = pulses[key](currentState, ...args);\n\n        if (pulseResult instanceof Promise) {\n          return pulseResult\n            .then((resolvedValue) => {\n              setState(currentState as StateType);\n              return resolvedValue;\n            })\n            .catch((error) => {\n              console.error(`Error in pulse '${key}':`, error);\n              throw error;\n            });\n        } else {\n          setState(currentState);\n          return pulseResult;\n        }\n      } catch (error) {\n        console.error(`Error in pulse '${key}':`, error);\n        throw error;\n      }\n    };\n  }\n\n  syncState(localState);\n\n  const pulsesProxy = new Proxy(boundPulses, {\n    get: (pulses, prop: string) => {\n      if (prop === \"state\") {\n        return proxyState;\n      }\n\n      if (!(prop in pulses)) {\n        throw new Error(`Pulse '${prop}' does not exist`);\n      }\n      return pulses[prop];\n    }\n  });\n\n  return pulsesProxy as StorePulses<PulsesType> & { state: ProxyState<StateType> };\n}\n\n// Create a immutable store with an unfrozen state, balance between security and flexibility\nexport function createPulseStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  return createStore(initialState, pulses, true);\n}\n\n// Create a mutable store with a unfrozen state to allow more flexibility\nexport function createMutableStore<StateType extends State, PulsesType extends Pulses<StateType>>(\n  initialState: StateType,\n  pulses: PulsesType\n): StorePulses<PulsesType> & { state: ProxyState<StateType> } {\n  console.warn(\n    \"Warning: You are working with a mutable state. This can lead to unpredictable behavior. All state changes made outside of a pulse will not trigger a re-render.\"\n  );\n  return createStore(initialState, pulses, false);\n}\n\nexport function createEffect(effect: Function) {\n  const runEffect = () => {\n    try {\n      effectStack.push(runEffect);\n      effect();\n    } finally {\n      effectStack.pop();\n    }\n  };\n\n  runEffect();\n}\n"],
  "mappings": "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",
  "names": ["pulses"]
}
