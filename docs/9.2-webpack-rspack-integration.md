# 9.2. Webpack/Rspack Integration

Use this path when your organization already standardizes on Webpack or Rspack.

Prerequisite:

- [./3.1-runtime-core.md](./3.1-runtime-core.md)

## Goal

1. Compile TSX with Valyrian JSX factories (`v` / `v.fragment`).
2. Run local dev server.
3. Build a production bundle with the same transform assumptions.

## Install

```bash
npm i valyrian.js
npm i -D typescript
```

Create `src/main.tsx`:

```tsx
import { mount, v } from "valyrian.js";

function App() {
  return (
    <main style="font-family: sans-serif; padding: 2rem;">
      <h1>Valyrian Bundled App</h1>
      <p>Webpack/Rspack integration is working.</p>
    </main>
  );
}

mount("#app", App);
```

## TypeScript JSX Settings (Required)

```json
{
  "compilerOptions": {
    "jsx": "react",
    "jsxFactory": "v",
    "jsxFragmentFactory": "v.fragment"
  }
}
```

## Webpack Recipe

Install:

```bash
npm i -D webpack webpack-cli webpack-dev-server ts-loader html-webpack-plugin
```

`webpack.config.cjs`:

```js
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  mode: process.env.NODE_ENV || "development",
  entry: "./src/main.tsx",
  devtool: "source-map",
  resolve: {
    extensions: [".tsx", ".ts", ".js"]
  },
  module: {
    rules: [
      {
        test: /\.[tj]sx?$/,
        exclude: /node_modules/,
        use: {
          loader: "ts-loader",
          options: {
            transpileOnly: true
          }
        }
      }
    ]
  },
  plugins: [new HtmlWebpackPlugin({ template: "./index.html" })],
  devServer: {
    port: 5173,
    historyApiFallback: true
  },
  output: {
    clean: true,
    filename: "assets/app.js"
  }
};
```

Scripts:

```json
{
  "scripts": {
    "dev:webpack": "webpack serve",
    "build:webpack": "webpack --mode production"
  }
}
```

## Rspack Recipe

Install:

```bash
npm i -D @rspack/core @rspack/cli @rspack/dev-server
```

`rspack.config.cjs`:

```js
const { rspack } = require("@rspack/core");

module.exports = {
  mode: process.env.NODE_ENV || "development",
  entry: "./src/main.tsx",
  resolve: {
    extensions: [".tsx", ".ts", ".js"]
  },
  module: {
    rules: [
      {
        test: /\.[tj]sx?$/,
        exclude: /node_modules/,
        loader: "builtin:swc-loader",
        options: {
          jsc: {
            parser: {
              syntax: "typescript",
              tsx: true
            },
            transform: {
              react: {
                runtime: "classic",
                pragma: "v",
                pragmaFrag: "v.fragment"
              }
            }
          }
        }
      }
    ]
  },
  plugins: [new rspack.HtmlRspackPlugin({ template: "./index.html" })],
  devServer: {
    port: 5174,
    historyApiFallback: true
  },
  output: {
    clean: true,
    filename: "assets/app.js"
  }
};
```

Scripts:

```json
{
  "scripts": {
    "dev:rspack": "rspack serve",
    "build:rspack": "rspack build --mode production"
  }
}
```

## Verify

```bash
npm run dev:webpack
npm run build:webpack
npm run dev:rspack
npm run build:rspack
```

Expected outcome: both bundlers render the same app and complete production builds without JSX factory errors.

## Key Points

Required for correctness:

1. Keep JSX transform in classic mode with `v` / `v.fragment`.
2. Keep `v` in scope in TSX modules.

Recommended practice:

1. Keep one stable mount root (`#app` or `body`) across bundler targets.
2. Keep parity checks between Webpack and Rspack output behavior before release.

## Practical Baseline

Start with one entry file and one render target, then add code-splitting or advanced plugin chains after first render works.
