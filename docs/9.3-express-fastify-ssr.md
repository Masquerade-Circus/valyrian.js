# 9.3. Express/Fastify SSR (Request-Scoped Isolation)

This recipe shows a request-scoped SSR flow for Express/Fastify with hydration continuity and no cross-request state leaks.

Goal:

1. SSR prefetch for `/users/:id/edit` so first paint already has form data.
2. Hydrate in browser with the same data shape.
3. Do a client freshness refetch after hydration.
4. Avoid leaking headers/storage/state between concurrent requests.

---

## Client

### 1) `app/views/edit-user.page.tsx`

Instance-scoped page factory:

- Creates one `PulseStore` per navigation.
- Creates one `FormStore` per page instance.
- Keeps `load()` and `refresh()` public methods while sharing one internal fetch cycle.
- If SSR provided `initialUser`, the form renders immediately.
- On client mount, it refetches for freshness.
- If form is dirty, server refresh does not overwrite local edits.

```tsx
// app/views/edit-user.page.tsx
import { isNodeJs, onCreate } from "valyrian.js";
import { FormStore } from "valyrian.js/forms";
import { createPulseStore } from "valyrian.js/pulses";

type User = { id: string; name: string; email: string };
type EditUserValues = { name: string; email: string };
type EditUserState = {
  user: User | null;
  loading: boolean;
  refreshing: boolean;
  error: Error | null;
  serverUpdatedWhileDirty: boolean;
};
type ReadMode = "load" | "refresh";

type EditUserDeps = {
  api: any; // request.new(...)
  userId: string;
  initialUser?: User | null;
};

export function createEditUserPage({ api, userId, initialUser = null }: EditUserDeps) {
  let form: FormStore<EditUserValues> | null = null;

  function toError(error: unknown) {
    return error instanceof Error ? error : new Error(String(error));
  }

  function applyServerUserToForm(state: EditUserState, user: User) {
    state.user = user;

    if (!form) {
      form = createForm(user);
      return;
    }

    if (form.isDirty) {
      state.serverUpdatedWhileDirty = true;
      return;
    }

    form = createForm(user);
  }

  async function runFetchCycle(state: EditUserState, mode: ReadMode, flush: () => void) {
    const isLoad = mode === "load";

    if (isLoad) {
      state.loading = true;
    } else {
      state.refreshing = true;
    }

    state.error = null;
    state.serverUpdatedWhileDirty = false;
    flush();

    try {
      const user = (await api.get(`/api/users/${userId}`)) as User;
      applyServerUserToForm(state, user);
    } catch (error) {
      state.error = toError(error);
    } finally {
      if (isLoad) {
        state.loading = false;
      } else {
        state.refreshing = false;
      }
    }
  }

  const store = createPulseStore(
    {
      user: initialUser as User | null,
      loading: initialUser ? false : true,
      refreshing: false,
      error: null as Error | null,
      serverUpdatedWhileDirty: false
    },
    {
      async load(state) {
        await runFetchCycle(state, "load", this.$flush);
      },

      async refresh(state) {
        const mode: ReadMode = state.user ? "refresh" : "load";
        await runFetchCycle(state, mode, this.$flush);
      },

      async save(state, values: EditUserValues) {
        state.error = null;
        this.$flush();

        try {
          await api.put(`/api/users/${userId}`, values);
          if (state.user) {
            state.user = { ...state.user, ...values };
          }
        } catch (error) {
          state.error = toError(error);
          throw state.error;
        }
      }
    }
  );

  function createForm(user: User) {
    return new FormStore<EditUserValues>({
      state: {
        name: user.name || "",
        email: user.email || ""
      },
      schema: {
        type: "object",
        properties: {
          name: { type: "string", minLength: 1 },
          email: { type: "string", format: "email" }
        },
        required: ["name", "email"]
      },
      clean: {
        name: (value: unknown) => String(value).trim(),
        email: (value: unknown) => String(value).trim().toLowerCase()
      },
      onSubmit: async (values) => {
        await store.save(values);
      }
    });
  }

  if (initialUser) {
    form = createForm(initialUser);
  }

  function EditUserPage() {
    onCreate(() => {
      if (isNodeJs) {
        return;
      }

      void store.refresh();
    });

    if (store.state.loading || !store.state.user || !form) {
      return (
        <main>
          <p>Loading...</p>
        </main>
      );
    }

    return (
      <main>
        <header style="display:flex; gap:1rem; align-items:center;">
          <h1>Edit user {userId}</h1>
          <span v-if={store.state.refreshing} style="opacity:0.7;">
            Refreshing...
          </span>
        </header>

        <p v-if={store.state.serverUpdatedWhileDirty} style="opacity:0.8;">
          Newer server data exists but was not applied because the form is already dirty.
        </p>

        <p v-if={store.state.error} style="color:crimson;">
          {store.state.error.message}
        </p>

        <form v-form={form}>
          <label>Name</label>
          <input name="name" v-field={form} />
          <p v-if={form.errors.name} style="color:crimson;">
            {form.errors.name}
          </p>

          <label>Email</label>
          <input name="email" type="email" v-field={form} />
          <p v-if={form.errors.email} style="color:crimson;">
            {form.errors.email}
          </p>

          <div style="display:flex; gap:0.75rem; margin-top:1rem;">
            <button type="submit" disabled={form.isInflight}>
              {form.isInflight ? "Saving..." : "Save"}
            </button>

            <button type="button" onclick={() => store.refresh()} disabled={store.state.refreshing}>
              {store.state.refreshing ? "Refreshing..." : "Refetch"}
            </button>
          </div>
        </form>
      </main>
    );
  }

  return EditUserPage;
}
```

### 2) `app/router.tsx`

Creates one page instance per route navigation. If hydration state matches route id, it reuses that user as `initialUser`.

```tsx
// app/router.tsx
import { Router } from "valyrian.js/router";
import { createEditUserPage } from "./views/edit-user.page";

type User = { id: string; name: string; email: string };

export type ClientAppContext = {
  api: any; // request.new(...)
  initialState: {
    userId?: string;
    user?: User | null;
  };
};

export function createClientRouter(ctx: ClientAppContext) {
  const router = new Router();

  router.add("/", () => <h1>Home</h1>);

  router.add("/users/:id/edit", (req) => {
    const id = req.params.id as string;

    const initialUser =
      ctx.initialState.user && ctx.initialState.userId === id ? (ctx.initialState.user as User) : null;

    return createEditUserPage({
      api: ctx.api,
      userId: id,
      initialUser
    });
  });

  router.catch(404, () => <h1>Not found</h1>);

  return router;
}
```

### 3) `client-entry.tsx`

Hydrates from server-provided state and mounts router on the same container (`body`) used in server shell.

```tsx
// client-entry.tsx
import { mountRouter } from "valyrian.js/router";
import { request } from "valyrian.js/request";
import { createClientRouter } from "./app/router";

declare global {
  interface Window {
    __INITIAL_STATE__?: any;
  }
}

const initialState = window.__INITIAL_STATE__ || {};

const api = request.new("", {
  headers: { "Content-Type": "application/json" }
});

const router = createClientRouter({ api, initialState });
mountRouter("body", router);
```

Why pass `api` explicitly?

- It keeps request boundaries visible in the example.
- In Node request context (`ServerStorage.run(...)`), the exported `request` singleton can also resolve the contextual scoped client automatically.

---

## Server

### 1) `app/app-shell.tsx`

Renders full HTML document into `body` and safely serializes hydration state.

```tsx
// app/app-shell.tsx
export function AppShell({ routeHtml, initialState }: { routeHtml: string; initialState: any }) {
  const serialized = JSON.stringify(initialState)
    .replace(/</g, "\\u003c")
    .replace(/\u2028/g, "\\u2028")
    .replace(/\u2029/g, "\\u2029");

  const full = `${routeHtml}<script>window.__INITIAL_STATE__=${serialized};</script><script type="module" src="/client-entry.js"></script>`;

  return (
    <>
      {"<!doctype html>"}
      <html lang="en">
        <head>
          <meta charSet="utf-8" />
          <meta name="viewport" content="width=device-width,initial-scale=1" />
          <title>Valyrian SSR</title>
        </head>
        <body v-html={full} />
      </html>
    </>
  );
}
```

### 2) `app/server-router.tsx`

Creates a per-request router, prefetches user for SSR route, and writes hydration data into per-request `initialState`.

```tsx
// app/server-router.tsx
import { Router } from "valyrian.js/router";
import { createEditUserPage } from "./views/edit-user.page";

type User = { id: string; name: string; email: string };

export type ServerAppContext = {
  api: any; // request.new(...) per request
  initialState: {
    path: string;
    userId?: string;
    user?: User | null;
  };
};

export function createServerRouter(ctx: ServerAppContext) {
  const router = new Router();

  router.add("/", () => <h1>Home</h1>);

  router.add("/users/:id/edit", async (req) => {
    const id = req.params.id as string;

    const user = (await ctx.api.get(`/api/users/${id}`)) as User;

    ctx.initialState.userId = id;
    ctx.initialState.user = user;

    return createEditUserPage({
      api: ctx.api,
      userId: id,
      initialUser: user
    });
  });

  router.catch(404, () => <h1>Not found</h1>);

  return router;
}
```

### 3) `server.ts`

Per-request isolation:

- `ServerStorage.run(...)` per incoming request.
- `initialState` created per request.
- `request.new(...)` created per request with request-scoped headers.
- `createServerRouter(...)` created per request.

```tsx
// server.ts
import express from "express";

// Import node runtime before SSR/storage-dependent logic.
import "valyrian.js/node";

import { render, ServerStorage } from "valyrian.js/node";
import { request } from "valyrian.js/request";

import { AppShell } from "./app/app-shell";
import { createServerRouter } from "./app/server-router";

const app = express();

app.use(express.static("public"));

app.get("*", (req, res, next) => {
  ServerStorage.run(() => {
    void (async () => {
      const initialState = {
        path: req.url,
        userId: undefined as string | undefined,
        user: null as any
      };

      const nodeOrigin = `${req.protocol}://${req.get("host")}`;

      const api = request.new("", {
        headers: {
          Cookie: req.headers.cookie || "",
          Authorization: req.headers.authorization || "",
          "Content-Type": "application/json"
        },
        urls: {
          base: "",
          node: nodeOrigin
        }
      });

      const router = createServerRouter({ api, initialState });

      const routeHtml = (await router.go(req.url)) || "";
      const html = render(<AppShell routeHtml={routeHtml} initialState={initialState} />);

      res.type("html").send(html);
    })().catch(next);
  });
});

app.listen(3000, () => {
  console.log("SSR on http://localhost:3000");
});
```

Fastify variant (short):

Use the same per-request flow (`ServerStorage.run` -> `request.new` -> `createServerRouter` -> `render`) with Fastify.

```tsx
import fastify from "fastify";
import "valyrian.js/node";
import { render, ServerStorage } from "valyrian.js/node";
import { request as requestClient } from "valyrian.js/request";

const app = fastify();

app.get("/*", async (httpRequest, reply) => {
  return ServerStorage.run(async () => {
    const initialState = { path: httpRequest.url, userId: undefined as string | undefined, user: null as any };
    const nodeOrigin = `${httpRequest.protocol}://${String(httpRequest.headers.host || "localhost")}`;

    const api = requestClient.new("", {
      headers: {
        Cookie: String(httpRequest.headers.cookie || ""),
        Authorization: String(httpRequest.headers.authorization || ""),
        "Content-Type": "application/json"
      },
      urls: {
        base: "",
        node: nodeOrigin
      }
    });

    const router = createServerRouter({ api, initialState });
    const routeHtml = (await router.go(httpRequest.url)) || "";
    const html = render(<AppShell routeHtml={routeHtml} initialState={initialState} />);

    return reply.type("text/html").send(html);
  });
});
```

Note: Keep the same isolation rules as the Express example - one `ServerStorage.run(...)`, one `request.new(...)`, and one router instance per incoming request.

---

## Why this avoids cross-request leakage

1. No shared mutable `initialState` singleton.
2. No shared request client with mutable headers.
3. No shared router instance for server requests.
4. Storage context isolated by `ServerStorage.run(...)`.
5. Client hydration uses only serialized state from that specific response.

Container note:

- In Node.js SSR, `router.go(...)` falls back to `mount("body", ...)` when no router container is explicitly set.
- The core runtime checks `isNodeJs` and creates a fresh element for that string container instead of querying a global DOM node.
- That keeps concurrent SSR requests from overwriting the same shared element.

## Two-stage UX behavior

1. **SSR/first paint:** route prefetch fills `initialUser`, form renders immediately.
2. **Client freshness pass:** `onCreate` runs `refresh()` on browser only.
3. **Dirty protection:** if user already edited fields, refresh does not overwrite form values.

## Production Hardening Note

If `refresh()` can run concurrently (for example, auto-refresh + manual refetch), guard against stale responses overwriting newer state. A simple request-id/token check per fetch cycle is usually enough.
