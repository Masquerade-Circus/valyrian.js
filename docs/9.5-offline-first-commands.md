# 9.5. Offline-First Commands

Use this recipe when users must be able to submit commands while offline (for example, creating orders or saving drafts).

Prerequisite:

- [./4.2.6-offline.md](./4.2.6-offline.md)

## Goal

1. Accept commands immediately in UI.
2. Queue commands when offline.
3. Sync automatically when online.
4. Surface pending/failed status and recovery controls.

## Command Queue Setup

```ts
import { OfflineQueue } from "valyrian.js/offline";
import { NetworkManager } from "valyrian.js/network";
import { request } from "valyrian.js/request";

const api = request.new("", {
  headers: { "Content-Type": "application/json" }
});

const queue = new OfflineQueue({
  id: "checkout-commands",
  network: new NetworkManager(),
  handler: (operation) =>
    api.post(`/api/commands/${operation.type}`, {
      ...operation.payload,
      commandId: operation.id
    }),
  isRetryable: (error) => {
    const status = (error as any)?.response?.status;
    return status === 429 || (status >= 500 && status < 600);
  },
  backoff: {
    strategy: "exponential",
    baseMs: 300,
    maxMs: 5000
  },
  maxRetries: 5
});
```

Why `commandId` in payload?

- It lets your backend dedupe retries safely.
- It keeps command handling idempotent under flaky connections.

## Submit Flow (UI Action)

```ts
async function submitCreateOrder(order: { sku: string; qty: number }) {
  queue.enqueue({
    type: "create-order",
    payload: order
  });

  // Optional immediate attempt. If offline, queue sync exits early.
  await queue.sync();
}
```

## Status + Recovery Hooks

```ts
queue.on("change", (state) => {
  // Render badges/counters from state.pending, state.failed, state.syncing
  console.log("pending", state.pending, "failed", state.failed, "syncing", state.syncing);
});

queue.on("sync:error", ({ operation, error }) => {
  console.error("command failed", operation.id, error);
});

async function retryFirstFailed() {
  const failed = queue.failed();
  if (!failed.length) return;
  await queue.retryOne(failed[0].id);
}
```

## Operational Rules

1. Keep command payloads deterministic and schema-stable.
2. Make server handlers idempotent by `commandId`.
3. Expose pending/failed/syncing in UI so users understand eventual consistency.
4. Call `queue.destroy()` when the queue is no longer needed.
